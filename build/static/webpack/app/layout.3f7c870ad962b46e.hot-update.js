"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./data/dataService.ts":
/*!*****************************!*\
  !*** ./data/dataService.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockDataService: function() { return /* binding */ MockDataService; },\n/* harmony export */   dataService: function() { return /* binding */ dataService; }\n/* harmony export */ });\n/* harmony import */ var _sampleData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sampleData */ \"(app-pages-browser)/./data/sampleData.ts\");\n/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings */ \"(app-pages-browser)/./data/strings.ts\");\n\n\n// Helper function to safely access localStorage\nconst getLocalStorage = (key)=>{\n    if ( true && window.localStorage) {\n        return window.localStorage.getItem(key);\n    }\n    return null;\n};\nconst setLocalStorage = (key, value)=>{\n    if ( true && window.localStorage) {\n        window.localStorage.setItem(key, value);\n    }\n};\nconst removeLocalStorage = (key)=>{\n    if ( true && window.localStorage) {\n        window.localStorage.removeItem(key);\n    }\n};\n// Mock implementation that simulates database operations\nclass MockDataService {\n    loadData() {\n        const savedData = getLocalStorage(\"circle-data\");\n        if (savedData) {\n            try {\n                const parsed = JSON.parse(savedData);\n                // Validate data structure\n                if (this.isValidData(parsed)) {\n                    this.data = parsed;\n                } else {\n                    console.warn(\"MockDataService: Invalid data format, using sample data\");\n                    removeLocalStorage(\"circle-data\");\n                }\n            } catch (error) {\n                console.error(\"MockDataService: Failed to parse saved data, using sample data\");\n                removeLocalStorage(\"circle-data\");\n            }\n        }\n    }\n    isValidData(data) {\n        return data.subjects && Array.isArray(data.subjects) && data.relationships && Array.isArray(data.relationships) && data.contacts && Array.isArray(data.contacts) && data.organizations && Array.isArray(data.organizations) && data.occupations && Array.isArray(data.occupations) && data.sentiments && Array.isArray(data.sentiments) && data.notes && Array.isArray(data.notes);\n    }\n    saveData() {\n        setLocalStorage(\"circle-data\", JSON.stringify(this.data));\n    }\n    simulateDelay() {\n        // Simulate network delay (50-200ms)\n        const delay = Math.random() * 150 + 50;\n        return new Promise((resolve)=>setTimeout(resolve, delay));\n    }\n    async updateContact(id, updates) {\n        await this.simulateDelay();\n        const contactIndex = this.data.contacts.findIndex((c)=>c.id === id);\n        if (contactIndex === -1) {\n            throw new Error(\"Contact with id \".concat(id, \" not found\"));\n        }\n        // Update the contact\n        this.data.contacts[contactIndex] = {\n            ...this.data.contacts[contactIndex],\n            ...updates\n        };\n        this.saveData();\n        return this.data.contacts[contactIndex];\n    }\n    async addContact(contact) {\n        await this.simulateDelay();\n        const newContact = {\n            ...contact,\n            id: Date.now(),\n            isTrashed: false\n        };\n        this.data.contacts.push(newContact);\n        this.saveData();\n        return newContact;\n    }\n    async deleteContact(id) {\n        await this.simulateDelay();\n        this.loadData(); // Ensure data is loaded\n        const initialLength = this.data.contacts.length;\n        this.data.contacts = this.data.contacts.filter((c)=>c.id !== id);\n        if (this.data.contacts.length === initialLength) {\n            throw new Error(\"Contact with id \".concat(id, \" not found\"));\n        }\n        this.saveData();\n    }\n    async addSubject(subject) {\n        await this.simulateDelay();\n        const newSubject = {\n            ...subject,\n            id: Date.now()\n        };\n        this.data.subjects.push(newSubject);\n        this.saveData();\n        return newSubject;\n    }\n    async addOrganization(organization) {\n        await this.simulateDelay();\n        const newOrganization = {\n            ...organization,\n            id: Date.now()\n        };\n        this.data.organizations.push(newOrganization);\n        this.saveData();\n        return newOrganization;\n    }\n    async addOccupation(occupation) {\n        await this.simulateDelay();\n        const newOccupation = {\n            ...occupation,\n            id: Date.now()\n        };\n        this.data.occupations.push(newOccupation);\n        this.saveData();\n        return newOccupation;\n    }\n    async addRelationship(relationship) {\n        await this.simulateDelay();\n        const newRelationship = {\n            ...relationship,\n            id: Date.now()\n        };\n        this.data.relationships.push(newRelationship);\n        this.saveData();\n        return newRelationship;\n    }\n    async addSentiment(sentiment) {\n        await this.simulateDelay();\n        const newSentiment = {\n            ...sentiment,\n            id: Date.now()\n        };\n        this.data.sentiments.push(newSentiment);\n        this.saveData();\n        return newSentiment;\n    }\n    async addNote(note) {\n        await this.simulateDelay();\n        // Resolve any {{contact:ID}} tokens in text to the latest contact name\n        const resolvedText = (0,_strings__WEBPACK_IMPORTED_MODULE_1__.resolveContactTokens)(note.text, this.data.contacts);\n        const newNote = {\n            ...note,\n            text: resolvedText,\n            id: Date.now(),\n            createdAt: new Date().toISOString(),\n            isTrashed: false\n        };\n        this.data.notes.push(newNote);\n        this.saveData();\n        return newNote;\n    }\n    async updateNote(id, updates) {\n        await this.simulateDelay();\n        const noteIndex = this.data.notes.findIndex((n)=>n.id === id);\n        if (noteIndex === -1) {\n            throw new Error(\"Note with id \".concat(id, \" not found\"));\n        }\n        // Update the note\n        this.data.notes[noteIndex] = {\n            ...this.data.notes[noteIndex],\n            ...updates\n        };\n        this.saveData();\n        return this.data.notes[noteIndex];\n    }\n    async addCommitment(commitment) {\n        await this.simulateDelay();\n        const newCommitment = {\n            ...commitment,\n            id: Date.now()\n        };\n        this.data.commitments.push(newCommitment);\n        this.saveData();\n        return newCommitment;\n    }\n    async updateCommitment(id, updates) {\n        await this.simulateDelay();\n        const idx = this.data.commitments.findIndex((c)=>c.id === id);\n        if (idx === -1) throw new Error(\"Commitment with id \".concat(id, \" not found\"));\n        this.data.commitments[idx] = {\n            ...this.data.commitments[idx],\n            ...updates\n        };\n        this.saveData();\n        return this.data.commitments[idx];\n    }\n    async getAllData() {\n        var _this_data_contacts_, _this_data_contacts_1;\n        console.log(\"\\uD83D\\uDCE1 MockDataService: getAllData called\");\n        console.log(\"\\uD83D\\uDD0D MockDataService: Current internal data source:\", {\n            isFromLocalStorage: this.data !== (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)(),\n            contactsCount: this.data.contacts.length,\n            sampleContactName: ((_this_data_contacts_ = this.data.contacts[0]) === null || _this_data_contacts_ === void 0 ? void 0 : _this_data_contacts_.name) || \"none\"\n        });\n        await this.simulateDelay();\n        // Reload from localStorage to get latest data\n        console.log(\"\\uD83D\\uDD04 MockDataService: Reloading from localStorage before returning data\");\n        this.loadData();\n        console.log(\"\\uD83D\\uDCE4 MockDataService: Returning data to caller:\", {\n            contactsCount: this.data.contacts.length,\n            notesCount: this.data.notes.length,\n            sampleContactName: ((_this_data_contacts_1 = this.data.contacts[0]) === null || _this_data_contacts_1 === void 0 ? void 0 : _this_data_contacts_1.name) || \"none\",\n            dataSource: this.data !== (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)() ? \"localStorage\" : \"sampleData\"\n        });\n        // Return a copy to prevent direct mutations\n        return {\n            contacts: [\n                ...this.data.contacts\n            ],\n            subjects: [\n                ...this.data.subjects\n            ],\n            organizations: [\n                ...this.data.organizations\n            ],\n            occupations: [\n                ...this.data.occupations\n            ],\n            relationships: [\n                ...this.data.relationships\n            ],\n            sentiments: [\n                ...this.data.sentiments\n            ],\n            notes: [\n                ...this.data.notes\n            ],\n            commitments: [\n                ...this.data.commitments\n            ]\n        };\n    }\n    constructor(){\n        // Initialize with sample data first, then try to load from localStorage\n        this.data = (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)();\n        // Load from localStorage only on the client side\n        if (true) {\n            this.loadData();\n        }\n    }\n}\n// Export singleton instance\nconst dataService = new MockDataService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzhCLE1BQU07WUFDeEN1QyxZQUFZLElBQUksQ0FBQzdFLElBQUksQ0FBQ1ksS0FBSyxDQUFDMEIsTUFBTTtZQUNsQ3FDLG1CQUFtQiw4QkFBSSxDQUFDM0UsSUFBSSxDQUFDUSxRQUFRLENBQUMsRUFBRSxjQUFyQixrRUFBdUJvRSxJQUFJLEtBQUk7WUFDbERFLFlBQVksSUFBSSxDQUFDOUUsSUFBSSxLQUFLbkIsMERBQWFBLEtBQUssaUJBQWlCO1FBQy9EO1FBRUEsNENBQTRDO1FBQzVDLE9BQU87WUFDTDJCLFVBQVU7bUJBQUksSUFBSSxDQUFDUixJQUFJLENBQUNRLFFBQVE7YUFBQztZQUNqQ0osVUFBVTttQkFBSSxJQUFJLENBQUNKLElBQUksQ0FBQ0ksUUFBUTthQUFDO1lBQ2pDSyxlQUFlO21CQUFJLElBQUksQ0FBQ1QsSUFBSSxDQUFDUyxhQUFhO2FBQUM7WUFDM0NDLGFBQWE7bUJBQUksSUFBSSxDQUFDVixJQUFJLENBQUNVLFdBQVc7YUFBQztZQUN2Q0gsZUFBZTttQkFBSSxJQUFJLENBQUNQLElBQUksQ0FBQ08sYUFBYTthQUFDO1lBQzNDSSxZQUFZO21CQUFJLElBQUksQ0FBQ1gsSUFBSSxDQUFDVyxVQUFVO2FBQUM7WUFDckNDLE9BQU87bUJBQUksSUFBSSxDQUFDWixJQUFJLENBQUNZLEtBQUs7YUFBQztZQUMzQndELGFBQWE7bUJBQUksSUFBSSxDQUFDcEUsSUFBSSxDQUFDb0UsV0FBVzthQUFDO1FBQ3pDO0lBQ0Y7SUE1UEFXLGFBQWM7UUFDWix3RUFBd0U7UUFDeEUsSUFBSSxDQUFDL0UsSUFBSSxHQUFHbkIsMERBQWFBO1FBQ3pCLGlEQUFpRDtRQUNqRCxJQUFJLElBQWtCLEVBQWE7WUFDakMsSUFBSSxDQUFDYSxRQUFRO1FBQ2Y7SUFDRjtBQXNQRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNc0YsY0FBYyxJQUFJdkYsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2RhdGEvZGF0YVNlcnZpY2UudHM/ZjhmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250YWN0LCBTdWJqZWN0LCBPcmdhbml6YXRpb24sIE9jY3VwYXRpb24sIFJlbGF0aW9uc2hpcCwgU2VudGltZW50LCBOb3RlLCBDb21taXRtZW50IH0gZnJvbSAnLi4vY29udGV4dHMvQ29udGFjdENvbnRleHQnO1xuaW1wb3J0IHsgZ2V0U2FtcGxlRGF0YSB9IGZyb20gJy4vc2FtcGxlRGF0YSc7XG5pbXBvcnQgeyByZXNvbHZlQ29udGFjdFRva2VucyB9IGZyb20gJy4vc3RyaW5ncyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVNlcnZpY2Uge1xuICB1cGRhdGVDb250YWN0KGlkOiBudW1iZXIsIHVwZGF0ZXM6IFBhcnRpYWw8Q29udGFjdD4pOiBQcm9taXNlPENvbnRhY3Q+O1xuICBhZGRDb250YWN0KGNvbnRhY3Q6IE9taXQ8Q29udGFjdCwgJ2lkJz4pOiBQcm9taXNlPENvbnRhY3Q+O1xuICBkZWxldGVDb250YWN0KGlkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuICBhZGRTdWJqZWN0KHN1YmplY3Q6IE9taXQ8U3ViamVjdCwgJ2lkJz4pOiBQcm9taXNlPFN1YmplY3Q+O1xuICBhZGRPcmdhbml6YXRpb24ob3JnYW5pemF0aW9uOiBPbWl0PE9yZ2FuaXphdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9yZ2FuaXphdGlvbj47XG4gIGFkZE9jY3VwYXRpb24ob2NjdXBhdGlvbjogT21pdDxPY2N1cGF0aW9uLCAnaWQnPik6IFByb21pc2U8T2NjdXBhdGlvbj47XG4gIGFkZFJlbGF0aW9uc2hpcChyZWxhdGlvbnNoaXA6IE9taXQ8UmVsYXRpb25zaGlwLCAnaWQnPik6IFByb21pc2U8UmVsYXRpb25zaGlwPjtcbiAgYWRkU2VudGltZW50KHNlbnRpbWVudDogT21pdDxTZW50aW1lbnQsICdpZCc+KTogUHJvbWlzZTxTZW50aW1lbnQ+O1xuICBhZGROb3RlKG5vdGU6IE9taXQ8Tm90ZSwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFByb21pc2U8Tm90ZT47XG4gIHVwZGF0ZU5vdGUoaWQ6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxOb3RlPik6IFByb21pc2U8Tm90ZT47XG4gIC8vIENvbW1pdG1lbnRzXG4gIGFkZENvbW1pdG1lbnQoY29tbWl0bWVudDogT21pdDxDb21taXRtZW50LCAnaWQnPik6IFByb21pc2U8Q29tbWl0bWVudD47XG4gIHVwZGF0ZUNvbW1pdG1lbnQoaWQ6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxDb21taXRtZW50Pik6IFByb21pc2U8Q29tbWl0bWVudD47XG4gIGdldEFsbERhdGEoKTogUHJvbWlzZTx7XG4gICAgY29udGFjdHM6IENvbnRhY3RbXTtcbiAgICBzdWJqZWN0czogU3ViamVjdFtdO1xuICAgIG9yZ2FuaXphdGlvbnM6IE9yZ2FuaXphdGlvbltdO1xuICAgIG9jY3VwYXRpb25zOiBPY2N1cGF0aW9uW107XG4gICAgcmVsYXRpb25zaGlwczogUmVsYXRpb25zaGlwW107XG4gICAgc2VudGltZW50czogU2VudGltZW50W107XG4gICAgbm90ZXM6IE5vdGVbXTtcbiAgICBjb21taXRtZW50czogQ29tbWl0bWVudFtdO1xuICB9Pjtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhZmVseSBhY2Nlc3MgbG9jYWxTdG9yYWdlXG5jb25zdCBnZXRMb2NhbFN0b3JhZ2UgPSAoa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBzZXRMb2NhbFN0b3JhZ2UgPSAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHJlbW92ZUxvY2FsU3RvcmFnZSA9IChrZXk6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9XG59O1xuXG4vLyBNb2NrIGltcGxlbWVudGF0aW9uIHRoYXQgc2ltdWxhdGVzIGRhdGFiYXNlIG9wZXJhdGlvbnNcbmV4cG9ydCBjbGFzcyBNb2NrRGF0YVNlcnZpY2UgaW1wbGVtZW50cyBEYXRhU2VydmljZSB7XG4gIHByaXZhdGUgZGF0YToge1xuICAgIGNvbnRhY3RzOiBDb250YWN0W107XG4gICAgc3ViamVjdHM6IFN1YmplY3RbXTtcbiAgICBvcmdhbml6YXRpb25zOiBPcmdhbml6YXRpb25bXTtcbiAgICBvY2N1cGF0aW9uczogT2NjdXBhdGlvbltdO1xuICAgIHJlbGF0aW9uc2hpcHM6IFJlbGF0aW9uc2hpcFtdO1xuICAgIHNlbnRpbWVudHM6IFNlbnRpbWVudFtdO1xuICAgIG5vdGVzOiBOb3RlW107XG4gICAgY29tbWl0bWVudHM6IENvbW1pdG1lbnRbXTtcbiAgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBJbml0aWFsaXplIHdpdGggc2FtcGxlIGRhdGEgZmlyc3QsIHRoZW4gdHJ5IHRvIGxvYWQgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICB0aGlzLmRhdGEgPSBnZXRTYW1wbGVEYXRhKCk7XG4gICAgLy8gTG9hZCBmcm9tIGxvY2FsU3RvcmFnZSBvbmx5IG9uIHRoZSBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2FkRGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbG9hZERhdGEoKSB7XG4gICAgY29uc3Qgc2F2ZWREYXRhID0gZ2V0TG9jYWxTdG9yYWdlKCdjaXJjbGUtZGF0YScpO1xuICAgIGlmIChzYXZlZERhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2F2ZWREYXRhKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERhdGEocGFyc2VkKSkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ01vY2tEYXRhU2VydmljZTogSW52YWxpZCBkYXRhIGZvcm1hdCwgdXNpbmcgc2FtcGxlIGRhdGEnKTtcbiAgICAgICAgICByZW1vdmVMb2NhbFN0b3JhZ2UoJ2NpcmNsZS1kYXRhJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vY2tEYXRhU2VydmljZTogRmFpbGVkIHRvIHBhcnNlIHNhdmVkIGRhdGEsIHVzaW5nIHNhbXBsZSBkYXRhJyk7XG4gICAgICAgIHJlbW92ZUxvY2FsU3RvcmFnZSgnY2lyY2xlLWRhdGEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzVmFsaWREYXRhKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXRhLnN1YmplY3RzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5zdWJqZWN0cykgJiYgXG4gICAgICAgICAgIGRhdGEucmVsYXRpb25zaGlwcyAmJiBBcnJheS5pc0FycmF5KGRhdGEucmVsYXRpb25zaGlwcykgJiZcbiAgICAgICAgICAgZGF0YS5jb250YWN0cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY29udGFjdHMpICYmXG4gICAgICAgICAgIGRhdGEub3JnYW5pemF0aW9ucyAmJiBBcnJheS5pc0FycmF5KGRhdGEub3JnYW5pemF0aW9ucykgJiZcbiAgICAgICAgICAgZGF0YS5vY2N1cGF0aW9ucyAmJiBBcnJheS5pc0FycmF5KGRhdGEub2NjdXBhdGlvbnMpICYmXG4gICAgICAgICAgIGRhdGEuc2VudGltZW50cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuc2VudGltZW50cykgJiZcbiAgICAgICAgICAgZGF0YS5ub3RlcyAmJiBBcnJheS5pc0FycmF5KGRhdGEubm90ZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlRGF0YSgpOiB2b2lkIHtcbiAgICBzZXRMb2NhbFN0b3JhZ2UoJ2NpcmNsZS1kYXRhJywgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKSk7XG4gIH1cblxuICBwcml2YXRlIHNpbXVsYXRlRGVsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gU2ltdWxhdGUgbmV0d29yayBkZWxheSAoNTAtMjAwbXMpXG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogMTUwICsgNTA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlQ29udGFjdChpZDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPENvbnRhY3Q+KTogUHJvbWlzZTxDb250YWN0PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgY29udGFjdEluZGV4ID0gdGhpcy5kYXRhLmNvbnRhY3RzLmZpbmRJbmRleChjID0+IGMuaWQgPT09IGlkKTtcbiAgICBpZiAoY29udGFjdEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250YWN0IHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgY29udGFjdFxuICAgIHRoaXMuZGF0YS5jb250YWN0c1tjb250YWN0SW5kZXhdID0geyBcbiAgICAgIC4uLnRoaXMuZGF0YS5jb250YWN0c1tjb250YWN0SW5kZXhdLCBcbiAgICAgIC4uLnVwZGF0ZXMgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb250YWN0c1tjb250YWN0SW5kZXhdO1xuICB9XG5cbiAgYXN5bmMgYWRkQ29udGFjdChjb250YWN0OiBPbWl0PENvbnRhY3QsICdpZCc+KTogUHJvbWlzZTxDb250YWN0PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgbmV3Q29udGFjdCA9IHsgXG4gICAgICAuLi5jb250YWN0LCBcbiAgICAgIGlkOiBEYXRlLm5vdygpLCAvLyBTaW1wbGUgSUQgZ2VuZXJhdGlvbiBmb3IgbW9ja1xuICAgICAgaXNUcmFzaGVkOiBmYWxzZVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5kYXRhLmNvbnRhY3RzLnB1c2gobmV3Q29udGFjdCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdDb250YWN0O1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQ29udGFjdChpZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgdGhpcy5sb2FkRGF0YSgpOyAvLyBFbnN1cmUgZGF0YSBpcyBsb2FkZWRcbiAgICBjb25zdCBpbml0aWFsTGVuZ3RoID0gdGhpcy5kYXRhLmNvbnRhY3RzLmxlbmd0aDtcbiAgICB0aGlzLmRhdGEuY29udGFjdHMgPSB0aGlzLmRhdGEuY29udGFjdHMuZmlsdGVyKChjOiBDb250YWN0KSA9PiBjLmlkICE9PSBpZCk7XG4gICAgXG4gICAgaWYgKHRoaXMuZGF0YS5jb250YWN0cy5sZW5ndGggPT09IGluaXRpYWxMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFjdCB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gIH1cblxuICBhc3luYyBhZGRTdWJqZWN0KHN1YmplY3Q6IE9taXQ8U3ViamVjdCwgJ2lkJz4pOiBQcm9taXNlPFN1YmplY3Q+IHtcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBcbiAgICBjb25zdCBuZXdTdWJqZWN0ID0geyBcbiAgICAgIC4uLnN1YmplY3QsIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEuc3ViamVjdHMucHVzaChuZXdTdWJqZWN0KTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld1N1YmplY3Q7XG4gIH1cblxuICBhc3luYyBhZGRPcmdhbml6YXRpb24ob3JnYW5pemF0aW9uOiBPbWl0PE9yZ2FuaXphdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9yZ2FuaXphdGlvbj4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld09yZ2FuaXphdGlvbiA9IHsgXG4gICAgICAuLi5vcmdhbml6YXRpb24sIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEub3JnYW5pemF0aW9ucy5wdXNoKG5ld09yZ2FuaXphdGlvbik7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdPcmdhbml6YXRpb247XG4gIH1cblxuICBhc3luYyBhZGRPY2N1cGF0aW9uKG9jY3VwYXRpb246IE9taXQ8T2NjdXBhdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9jY3VwYXRpb24+IHtcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBcbiAgICBjb25zdCBuZXdPY2N1cGF0aW9uID0geyBcbiAgICAgIC4uLm9jY3VwYXRpb24sIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEub2NjdXBhdGlvbnMucHVzaChuZXdPY2N1cGF0aW9uKTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld09jY3VwYXRpb247XG4gIH1cblxuICBhc3luYyBhZGRSZWxhdGlvbnNoaXAocmVsYXRpb25zaGlwOiBPbWl0PFJlbGF0aW9uc2hpcCwgJ2lkJz4pOiBQcm9taXNlPFJlbGF0aW9uc2hpcD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld1JlbGF0aW9uc2hpcCA9IHsgXG4gICAgICAuLi5yZWxhdGlvbnNoaXAsIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEucmVsYXRpb25zaGlwcy5wdXNoKG5ld1JlbGF0aW9uc2hpcCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdSZWxhdGlvbnNoaXA7XG4gIH1cblxuICBhc3luYyBhZGRTZW50aW1lbnQoc2VudGltZW50OiBPbWl0PFNlbnRpbWVudCwgJ2lkJz4pOiBQcm9taXNlPFNlbnRpbWVudD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld1NlbnRpbWVudCA9IHsgXG4gICAgICAuLi5zZW50aW1lbnQsIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEuc2VudGltZW50cy5wdXNoKG5ld1NlbnRpbWVudCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdTZW50aW1lbnQ7XG4gIH1cblxuICBhc3luYyBhZGROb3RlKG5vdGU6IE9taXQ8Tm90ZSwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFByb21pc2U8Tm90ZT4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIC8vIFJlc29sdmUgYW55IHt7Y29udGFjdDpJRH19IHRva2VucyBpbiB0ZXh0IHRvIHRoZSBsYXRlc3QgY29udGFjdCBuYW1lXG4gICAgY29uc3QgcmVzb2x2ZWRUZXh0ID0gcmVzb2x2ZUNvbnRhY3RUb2tlbnMobm90ZS50ZXh0LCB0aGlzLmRhdGEuY29udGFjdHMpO1xuICAgIGNvbnN0IG5ld05vdGUgPSB7IFxuICAgICAgLi4ubm90ZSwgXG4gICAgICB0ZXh0OiByZXNvbHZlZFRleHQsXG4gICAgICBpZDogRGF0ZS5ub3coKSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgaXNUcmFzaGVkOiBmYWxzZVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5kYXRhLm5vdGVzLnB1c2gobmV3Tm90ZSk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdOb3RlO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlTm90ZShpZDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPE5vdGU+KTogUHJvbWlzZTxOb3RlPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3Qgbm90ZUluZGV4ID0gdGhpcy5kYXRhLm5vdGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IGlkKTtcbiAgICBpZiAobm90ZUluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3RlIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgbm90ZVxuICAgIHRoaXMuZGF0YS5ub3Rlc1tub3RlSW5kZXhdID0geyBcbiAgICAgIC4uLnRoaXMuZGF0YS5ub3Rlc1tub3RlSW5kZXhdLCBcbiAgICAgIC4uLnVwZGF0ZXMgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5ub3Rlc1tub3RlSW5kZXhdO1xuICB9XG5cbiAgYXN5bmMgYWRkQ29tbWl0bWVudChjb21taXRtZW50OiBPbWl0PENvbW1pdG1lbnQsICdpZCc+KTogUHJvbWlzZTxDb21taXRtZW50PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgY29uc3QgbmV3Q29tbWl0bWVudDogQ29tbWl0bWVudCA9IHsgLi4uY29tbWl0bWVudCwgaWQ6IERhdGUubm93KCkgfTtcbiAgICB0aGlzLmRhdGEuY29tbWl0bWVudHMucHVzaChuZXdDb21taXRtZW50KTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld0NvbW1pdG1lbnQ7XG4gIH1cblxuICBhc3luYyB1cGRhdGVDb21taXRtZW50KGlkOiBudW1iZXIsIHVwZGF0ZXM6IFBhcnRpYWw8Q29tbWl0bWVudD4pOiBQcm9taXNlPENvbW1pdG1lbnQ+IHtcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBjb25zdCBpZHggPSB0aGlzLmRhdGEuY29tbWl0bWVudHMuZmluZEluZGV4KGMgPT4gYy5pZCA9PT0gaWQpO1xuICAgIGlmIChpZHggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYENvbW1pdG1lbnQgd2l0aCBpZCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB0aGlzLmRhdGEuY29tbWl0bWVudHNbaWR4XSA9IHsgLi4udGhpcy5kYXRhLmNvbW1pdG1lbnRzW2lkeF0sIC4uLnVwZGF0ZXMgfTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb21taXRtZW50c1tpZHhdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsRGF0YSgpOiBQcm9taXNlPHtcbiAgICBjb250YWN0czogQ29udGFjdFtdO1xuICAgIHN1YmplY3RzOiBTdWJqZWN0W107XG4gICAgb3JnYW5pemF0aW9uczogT3JnYW5pemF0aW9uW107XG4gICAgb2NjdXBhdGlvbnM6IE9jY3VwYXRpb25bXTtcbiAgICByZWxhdGlvbnNoaXBzOiBSZWxhdGlvbnNoaXBbXTtcbiAgICBzZW50aW1lbnRzOiBTZW50aW1lbnRbXTtcbiAgICBub3RlczogTm90ZVtdO1xuICB9PiB7XG4gICAgY29uc29sZS5sb2coJ/Cfk6EgTW9ja0RhdGFTZXJ2aWNlOiBnZXRBbGxEYXRhIGNhbGxlZCcpO1xuICAgIGNvbnNvbGUubG9nKCfwn5SNIE1vY2tEYXRhU2VydmljZTogQ3VycmVudCBpbnRlcm5hbCBkYXRhIHNvdXJjZTonLCB7XG4gICAgICBpc0Zyb21Mb2NhbFN0b3JhZ2U6IHRoaXMuZGF0YSAhPT0gZ2V0U2FtcGxlRGF0YSgpLFxuICAgICAgY29udGFjdHNDb3VudDogdGhpcy5kYXRhLmNvbnRhY3RzLmxlbmd0aCxcbiAgICAgIHNhbXBsZUNvbnRhY3ROYW1lOiB0aGlzLmRhdGEuY29udGFjdHNbMF0/Lm5hbWUgfHwgJ25vbmUnXG4gICAgfSk7XG4gICAgXG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgLy8gUmVsb2FkIGZyb20gbG9jYWxTdG9yYWdlIHRvIGdldCBsYXRlc3QgZGF0YVxuICAgIGNvbnNvbGUubG9nKCfwn5SEIE1vY2tEYXRhU2VydmljZTogUmVsb2FkaW5nIGZyb20gbG9jYWxTdG9yYWdlIGJlZm9yZSByZXR1cm5pbmcgZGF0YScpO1xuICAgIHRoaXMubG9hZERhdGEoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+TpCBNb2NrRGF0YVNlcnZpY2U6IFJldHVybmluZyBkYXRhIHRvIGNhbGxlcjonLCB7XG4gICAgICBjb250YWN0c0NvdW50OiB0aGlzLmRhdGEuY29udGFjdHMubGVuZ3RoLFxuICAgICAgbm90ZXNDb3VudDogdGhpcy5kYXRhLm5vdGVzLmxlbmd0aCxcbiAgICAgIHNhbXBsZUNvbnRhY3ROYW1lOiB0aGlzLmRhdGEuY29udGFjdHNbMF0/Lm5hbWUgfHwgJ25vbmUnLFxuICAgICAgZGF0YVNvdXJjZTogdGhpcy5kYXRhICE9PSBnZXRTYW1wbGVEYXRhKCkgPyAnbG9jYWxTdG9yYWdlJyA6ICdzYW1wbGVEYXRhJ1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBkaXJlY3QgbXV0YXRpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhY3RzOiBbLi4udGhpcy5kYXRhLmNvbnRhY3RzXSxcbiAgICAgIHN1YmplY3RzOiBbLi4udGhpcy5kYXRhLnN1YmplY3RzXSxcbiAgICAgIG9yZ2FuaXphdGlvbnM6IFsuLi50aGlzLmRhdGEub3JnYW5pemF0aW9uc10sXG4gICAgICBvY2N1cGF0aW9uczogWy4uLnRoaXMuZGF0YS5vY2N1cGF0aW9uc10sXG4gICAgICByZWxhdGlvbnNoaXBzOiBbLi4udGhpcy5kYXRhLnJlbGF0aW9uc2hpcHNdLFxuICAgICAgc2VudGltZW50czogWy4uLnRoaXMuZGF0YS5zZW50aW1lbnRzXSxcbiAgICAgIG5vdGVzOiBbLi4udGhpcy5kYXRhLm5vdGVzXSxcbiAgICAgIGNvbW1pdG1lbnRzOiBbLi4udGhpcy5kYXRhLmNvbW1pdG1lbnRzXVxuICAgIH07XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGRhdGFTZXJ2aWNlID0gbmV3IE1vY2tEYXRhU2VydmljZSgpO1xuIl0sIm5hbWVzIjpbImdldFNhbXBsZURhdGEiLCJyZXNvbHZlQ29udGFjdFRva2VucyIsImdldExvY2FsU3RvcmFnZSIsImtleSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRMb2NhbFN0b3JhZ2UiLCJ2YWx1ZSIsInNldEl0ZW0iLCJyZW1vdmVMb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwiTW9ja0RhdGFTZXJ2aWNlIiwibG9hZERhdGEiLCJzYXZlZERhdGEiLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJpc1ZhbGlkRGF0YSIsImRhdGEiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwic3ViamVjdHMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWxhdGlvbnNoaXBzIiwiY29udGFjdHMiLCJvcmdhbml6YXRpb25zIiwib2NjdXBhdGlvbnMiLCJzZW50aW1lbnRzIiwibm90ZXMiLCJzYXZlRGF0YSIsInN0cmluZ2lmeSIsInNpbXVsYXRlRGVsYXkiLCJkZWxheSIsIk1hdGgiLCJyYW5kb20iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ1cGRhdGVDb250YWN0IiwiaWQiLCJ1cGRhdGVzIiwiY29udGFjdEluZGV4IiwiZmluZEluZGV4IiwiYyIsIkVycm9yIiwiYWRkQ29udGFjdCIsImNvbnRhY3QiLCJuZXdDb250YWN0IiwiRGF0ZSIsIm5vdyIsImlzVHJhc2hlZCIsInB1c2giLCJkZWxldGVDb250YWN0IiwiaW5pdGlhbExlbmd0aCIsImxlbmd0aCIsImZpbHRlciIsImFkZFN1YmplY3QiLCJzdWJqZWN0IiwibmV3U3ViamVjdCIsImFkZE9yZ2FuaXphdGlvbiIsIm9yZ2FuaXphdGlvbiIsIm5ld09yZ2FuaXphdGlvbiIsImFkZE9jY3VwYXRpb24iLCJvY2N1cGF0aW9uIiwibmV3T2NjdXBhdGlvbiIsImFkZFJlbGF0aW9uc2hpcCIsInJlbGF0aW9uc2hpcCIsIm5ld1JlbGF0aW9uc2hpcCIsImFkZFNlbnRpbWVudCIsInNlbnRpbWVudCIsIm5ld1NlbnRpbWVudCIsImFkZE5vdGUiLCJub3RlIiwicmVzb2x2ZWRUZXh0IiwidGV4dCIsIm5ld05vdGUiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZU5vdGUiLCJub3RlSW5kZXgiLCJuIiwiYWRkQ29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJuZXdDb21taXRtZW50IiwiY29tbWl0bWVudHMiLCJ1cGRhdGVDb21taXRtZW50IiwiaWR4IiwiZ2V0QWxsRGF0YSIsImxvZyIsImlzRnJvbUxvY2FsU3RvcmFnZSIsImNvbnRhY3RzQ291bnQiLCJzYW1wbGVDb250YWN0TmFtZSIsIm5hbWUiLCJub3Rlc0NvdW50IiwiZGF0YVNvdXJjZSIsImNvbnN0cnVjdG9yIiwiZGF0YVNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/dataService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./data/strings.ts":
/*!*************************!*\
  !*** ./data/strings.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTACT_STRINGS: function() { return /* binding */ CONTACT_STRINGS; },\n/* harmony export */   ERROR_STRINGS: function() { return /* binding */ ERROR_STRINGS; },\n/* harmony export */   GREETINGS: function() { return /* binding */ GREETINGS; },\n/* harmony export */   LOADING_STRINGS: function() { return /* binding */ LOADING_STRINGS; },\n/* harmony export */   MONTH_NAMES: function() { return /* binding */ MONTH_NAMES; },\n/* harmony export */   NAV_STRINGS: function() { return /* binding */ NAV_STRINGS; },\n/* harmony export */   STRINGS: function() { return /* binding */ STRINGS; },\n/* harmony export */   UI_STRINGS: function() { return /* binding */ UI_STRINGS; },\n/* harmony export */   formatYyyyMmDdToLong: function() { return /* binding */ formatYyyyMmDdToLong; },\n/* harmony export */   resolveContactTokens: function() { return /* binding */ resolveContactTokens; }\n/* harmony export */ });\n// Common text strings used throughout the Circle app\nconst STRINGS = {\n    // Navigation\n    NAV: {\n        CIRCLE: \"Circle\",\n        MEMO: \"Memo\",\n        CONTACTS: \"Contacts\",\n        USER: \"User\",\n        DEV: \"Dev\"\n    },\n    // Contact-related\n    CONTACT: {\n        NO_OCCUPATION: \"No occupation\",\n        NO_SUBJECTS: \"No subjects assigned\",\n        NOTES_COUNT: (count)=>\"\".concat(count, \" notes\"),\n        OVERFLOW_INDICATOR: (count)=>\"+\".concat(count),\n        NO_BIRTH_DATE: \"\",\n        NO_ORGANIZATION: \"\"\n    },\n    // Loading states\n    LOADING: {\n        CONTACTS: \"Loading contacts...\"\n    },\n    // Placeholder text\n    PLACEHOLDERS: {\n        SEARCH: \"Search contacts...\",\n        NO_RESULTS: \"No contacts found\",\n        NO_DATA: \"No data available\"\n    },\n    // Error messages\n    ERRORS: {\n        LOAD_FAILED: \"Failed to load contacts\",\n        SAVE_FAILED: \"Failed to save contact\",\n        PARSE_FAILED: \"Failed to parse saved data\"\n    },\n    // UI Elements\n    UI: {\n        EDIT: \"Edit\",\n        DELETE: \"Delete\",\n        ADD: \"Add\",\n        SAVE: \"Save\",\n        CANCEL: \"Cancel\",\n        CLOSE: \"Close\",\n        MENU: \"Menu\"\n    },\n    // Relationship categories\n    RELATIONSHIPS: {\n        PERSONAL: \"personal\",\n        PROFESSIONAL: \"professional\",\n        ROMANTIC: \"romantic\"\n    },\n    // Subject categories\n    SUBJECTS: {\n        ACTIVITY: \"activity\",\n        INTEREST: \"interest\",\n        HOBBY: \"hobby\",\n        ORGANIZATION: \"organization\"\n    }\n};\n// Greeting messages for the Circle app\nconst GREETINGS = [\n    \"Any news from your friends?\",\n    \"Who did you meet today?\",\n    \"How can I help with your relationships?\",\n    \"What's new with your contacts?\",\n    \"Ready to strengthen your social connections?\"\n];\n// Export individual categories for easier imports\nconst NAV_STRINGS = STRINGS.NAV;\nconst CONTACT_STRINGS = STRINGS.CONTACT;\nconst LOADING_STRINGS = STRINGS.LOADING;\nconst ERROR_STRINGS = STRINGS.ERRORS;\nconst UI_STRINGS = STRINGS.UI;\n// Date formatting utilities that avoid timezone conversions\nconst MONTH_NAMES = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n];\nfunction formatYyyyMmDdToLong(dateStr) {\n    // Expecting 'YYYY-MM-DD'; parse without using Date to avoid TZ shifts\n    const m = /^\\s*(\\d{4})-(\\d{2})-(\\d{2})\\s*$/.exec(dateStr);\n    if (!m) return dateStr;\n    const y = parseInt(m[1], 10);\n    const mo = parseInt(m[2], 10);\n    const d = parseInt(m[3], 10);\n    if (!y || mo < 1 || mo > 12 || d < 1 || d > 31) return dateStr;\n    const monthName = MONTH_NAMES[mo - 1];\n    return \"\".concat(monthName, \" \").concat(d, \", \").concat(y);\n}\nfunction resolveContactTokens(text, contacts) {\n    if (!text) return text;\n    const re = /\\{\\{\\s*contact\\s*:\\s*(\\d+)\\s*\\}\\}/g;\n    return text.replace(re, (_match, idStr)=>{\n        const id = Number(idStr);\n        const contact = contacts === null || contacts === void 0 ? void 0 : contacts.find((c)=>c.id === id);\n        var _contact_name;\n        return (_contact_name = contact === null || contact === void 0 ? void 0 : contact.name) !== null && _contact_name !== void 0 ? _contact_name : _match;\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUEsOEJBQUFBLFFBQVNHLElBQUksY0FBYkgsMkJBQUFBLGdCQUFpQko7SUFDMUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9kYXRhL3N0cmluZ3MudHM/M2IwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21tb24gdGV4dCBzdHJpbmdzIHVzZWQgdGhyb3VnaG91dCB0aGUgQ2lyY2xlIGFwcFxuZXhwb3J0IGNvbnN0IFNUUklOR1MgPSB7XG4gIC8vIE5hdmlnYXRpb25cbiAgTkFWOiB7XG4gICAgQ0lSQ0xFOiAnQ2lyY2xlJyxcbiAgICBNRU1POiAnTWVtbycsXG4gICAgQ09OVEFDVFM6ICdDb250YWN0cycsXG4gICAgVVNFUjogJ1VzZXInLFxuICAgIERFVjogJ0RldicsXG4gIH0sXG4gIFxuICAvLyBDb250YWN0LXJlbGF0ZWRcbiAgQ09OVEFDVDoge1xuICAgIE5PX09DQ1VQQVRJT046ICdObyBvY2N1cGF0aW9uJyxcbiAgICBOT19TVUJKRUNUUzogJ05vIHN1YmplY3RzIGFzc2lnbmVkJyxcbiAgICBOT1RFU19DT1VOVDogKGNvdW50OiBudW1iZXIpID0+IGAke2NvdW50fSBub3Rlc2AsXG4gICAgT1ZFUkZMT1dfSU5ESUNBVE9SOiAoY291bnQ6IG51bWJlcikgPT4gYCske2NvdW50fWAsXG4gICAgTk9fQklSVEhfREFURTogJycsXG4gICAgTk9fT1JHQU5JWkFUSU9OOiAnJyxcbiAgfSxcbiAgXG4gIC8vIExvYWRpbmcgc3RhdGVzXG4gIExPQURJTkc6IHtcbiAgICBDT05UQUNUUzogJ0xvYWRpbmcgY29udGFjdHMuLi4nLFxuICB9LFxuICBcbiAgLy8gUGxhY2Vob2xkZXIgdGV4dFxuICBQTEFDRUhPTERFUlM6IHtcbiAgICBTRUFSQ0g6ICdTZWFyY2ggY29udGFjdHMuLi4nLFxuICAgIE5PX1JFU1VMVFM6ICdObyBjb250YWN0cyBmb3VuZCcsXG4gICAgTk9fREFUQTogJ05vIGRhdGEgYXZhaWxhYmxlJyxcbiAgfSxcbiAgXG4gIC8vIEVycm9yIG1lc3NhZ2VzXG4gIEVSUk9SUzoge1xuICAgIExPQURfRkFJTEVEOiAnRmFpbGVkIHRvIGxvYWQgY29udGFjdHMnLFxuICAgIFNBVkVfRkFJTEVEOiAnRmFpbGVkIHRvIHNhdmUgY29udGFjdCcsXG4gICAgUEFSU0VfRkFJTEVEOiAnRmFpbGVkIHRvIHBhcnNlIHNhdmVkIGRhdGEnLFxuICB9LFxuICBcbiAgLy8gVUkgRWxlbWVudHNcbiAgVUk6IHtcbiAgICBFRElUOiAnRWRpdCcsXG4gICAgREVMRVRFOiAnRGVsZXRlJyxcbiAgICBBREQ6ICdBZGQnLFxuICAgIFNBVkU6ICdTYXZlJyxcbiAgICBDQU5DRUw6ICdDYW5jZWwnLFxuICAgIENMT1NFOiAnQ2xvc2UnLFxuICAgIE1FTlU6ICdNZW51JyxcbiAgfSxcbiAgXG4gIC8vIFJlbGF0aW9uc2hpcCBjYXRlZ29yaWVzXG4gIFJFTEFUSU9OU0hJUFM6IHtcbiAgICBQRVJTT05BTDogJ3BlcnNvbmFsJyxcbiAgICBQUk9GRVNTSU9OQUw6ICdwcm9mZXNzaW9uYWwnLFxuICAgIFJPTUFOVElDOiAncm9tYW50aWMnLFxuICB9LFxuICBcbiAgLy8gU3ViamVjdCBjYXRlZ29yaWVzXG4gIFNVQkpFQ1RTOiB7XG4gICAgQUNUSVZJVFk6ICdhY3Rpdml0eScsXG4gICAgSU5URVJFU1Q6ICdpbnRlcmVzdCcsXG4gICAgSE9CQlk6ICdob2JieScsXG4gICAgT1JHQU5JWkFUSU9OOiAnb3JnYW5pemF0aW9uJyxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbi8vIEdyZWV0aW5nIG1lc3NhZ2VzIGZvciB0aGUgQ2lyY2xlIGFwcFxuZXhwb3J0IGNvbnN0IEdSRUVUSU5HUyA9IFtcbiAgXCJBbnkgbmV3cyBmcm9tIHlvdXIgZnJpZW5kcz9cIixcbiAgXCJXaG8gZGlkIHlvdSBtZWV0IHRvZGF5P1wiLFxuICBcIkhvdyBjYW4gSSBoZWxwIHdpdGggeW91ciByZWxhdGlvbnNoaXBzP1wiLFxuICBcIldoYXQncyBuZXcgd2l0aCB5b3VyIGNvbnRhY3RzP1wiLFxuICBcIlJlYWR5IHRvIHN0cmVuZ3RoZW4geW91ciBzb2NpYWwgY29ubmVjdGlvbnM/XCIsXG5dIGFzIGNvbnN0O1xuXG5cblxuLy8gRXhwb3J0IGluZGl2aWR1YWwgY2F0ZWdvcmllcyBmb3IgZWFzaWVyIGltcG9ydHNcbmV4cG9ydCBjb25zdCBOQVZfU1RSSU5HUyA9IFNUUklOR1MuTkFWO1xuZXhwb3J0IGNvbnN0IENPTlRBQ1RfU1RSSU5HUyA9IFNUUklOR1MuQ09OVEFDVDtcbmV4cG9ydCBjb25zdCBMT0FESU5HX1NUUklOR1MgPSBTVFJJTkdTLkxPQURJTkc7XG5leHBvcnQgY29uc3QgRVJST1JfU1RSSU5HUyA9IFNUUklOR1MuRVJST1JTO1xuZXhwb3J0IGNvbnN0IFVJX1NUUklOR1MgPSBTVFJJTkdTLlVJO1xuXG4vLyBEYXRlIGZvcm1hdHRpbmcgdXRpbGl0aWVzIHRoYXQgYXZvaWQgdGltZXpvbmUgY29udmVyc2lvbnNcbmV4cG9ydCBjb25zdCBNT05USF9OQU1FUyA9IFtcbiAgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLFxuICAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXG5dIGFzIGNvbnN0O1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0WXl5eU1tRGRUb0xvbmcoZGF0ZVN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gRXhwZWN0aW5nICdZWVlZLU1NLUREJzsgcGFyc2Ugd2l0aG91dCB1c2luZyBEYXRlIHRvIGF2b2lkIFRaIHNoaWZ0c1xuICBjb25zdCBtID0gL15cXHMqKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlcXHMqJC8uZXhlYyhkYXRlU3RyKTtcbiAgaWYgKCFtKSByZXR1cm4gZGF0ZVN0cjtcbiAgY29uc3QgeSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcbiAgY29uc3QgbW8gPSBwYXJzZUludChtWzJdLCAxMCk7XG4gIGNvbnN0IGQgPSBwYXJzZUludChtWzNdLCAxMCk7XG4gIGlmICgheSB8fCBtbyA8IDEgfHwgbW8gPiAxMiB8fCBkIDwgMSB8fCBkID4gMzEpIHJldHVybiBkYXRlU3RyO1xuICBjb25zdCBtb250aE5hbWUgPSBNT05USF9OQU1FU1ttbyAtIDFdO1xuICByZXR1cm4gYCR7bW9udGhOYW1lfSAke2R9LCAke3l9YDtcbn1cblxuLy8gUmVwbGFjZSB0ZW1wbGF0ZSB0b2tlbnMgbGlrZSB7e2NvbnRhY3Q6SUR9fSB3aXRoIHRoZSBjb250YWN0J3MgY3VycmVudCBuYW1lXG5pbXBvcnQgeyBDb250YWN0IH0gZnJvbSAnLi4vY29udGV4dHMvQ29udGFjdENvbnRleHQnO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb250YWN0VG9rZW5zKHRleHQ6IHN0cmluZywgY29udGFjdHM6IENvbnRhY3RbXSk6IHN0cmluZyB7XG4gIGlmICghdGV4dCkgcmV0dXJuIHRleHQ7XG4gIGNvbnN0IHJlID0gL1xce1xce1xccypjb250YWN0XFxzKjpcXHMqKFxcZCspXFxzKlxcfVxcfS9nO1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlLCAoX21hdGNoLCBpZFN0cikgPT4ge1xuICAgIGNvbnN0IGlkID0gTnVtYmVyKGlkU3RyKTtcbiAgICBjb25zdCBjb250YWN0ID0gY29udGFjdHM/LmZpbmQoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgcmV0dXJuIGNvbnRhY3Q/Lm5hbWUgPz8gX21hdGNoO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJTVFJJTkdTIiwiTkFWIiwiQ0lSQ0xFIiwiTUVNTyIsIkNPTlRBQ1RTIiwiVVNFUiIsIkRFViIsIkNPTlRBQ1QiLCJOT19PQ0NVUEFUSU9OIiwiTk9fU1VCSkVDVFMiLCJOT1RFU19DT1VOVCIsImNvdW50IiwiT1ZFUkZMT1dfSU5ESUNBVE9SIiwiTk9fQklSVEhfREFURSIsIk5PX09SR0FOSVpBVElPTiIsIkxPQURJTkciLCJQTEFDRUhPTERFUlMiLCJTRUFSQ0giLCJOT19SRVNVTFRTIiwiTk9fREFUQSIsIkVSUk9SUyIsIkxPQURfRkFJTEVEIiwiU0FWRV9GQUlMRUQiLCJQQVJTRV9GQUlMRUQiLCJVSSIsIkVESVQiLCJERUxFVEUiLCJBREQiLCJTQVZFIiwiQ0FOQ0VMIiwiQ0xPU0UiLCJNRU5VIiwiUkVMQVRJT05TSElQUyIsIlBFUlNPTkFMIiwiUFJPRkVTU0lPTkFMIiwiUk9NQU5USUMiLCJTVUJKRUNUUyIsIkFDVElWSVRZIiwiSU5URVJFU1QiLCJIT0JCWSIsIk9SR0FOSVpBVElPTiIsIkdSRUVUSU5HUyIsIk5BVl9TVFJJTkdTIiwiQ09OVEFDVF9TVFJJTkdTIiwiTE9BRElOR19TVFJJTkdTIiwiRVJST1JfU1RSSU5HUyIsIlVJX1NUUklOR1MiLCJNT05USF9OQU1FUyIsImZvcm1hdFl5eXlNbURkVG9Mb25nIiwiZGF0ZVN0ciIsIm0iLCJleGVjIiwieSIsInBhcnNlSW50IiwibW8iLCJkIiwibW9udGhOYW1lIiwicmVzb2x2ZUNvbnRhY3RUb2tlbnMiLCJ0ZXh0IiwiY29udGFjdHMiLCJyZSIsInJlcGxhY2UiLCJfbWF0Y2giLCJpZFN0ciIsImlkIiwiTnVtYmVyIiwiY29udGFjdCIsImZpbmQiLCJjIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/strings.ts\n"));

/***/ })

});