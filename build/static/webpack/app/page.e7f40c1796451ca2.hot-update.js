"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./data/dataService.ts":
/*!*****************************!*\
  !*** ./data/dataService.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockDataService: function() { return /* binding */ MockDataService; },\n/* harmony export */   dataService: function() { return /* binding */ dataService; }\n/* harmony export */ });\n/* harmony import */ var _sampleData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sampleData */ \"(app-pages-browser)/./data/sampleData.ts\");\n\n// Helper function to safely access localStorage\nconst getLocalStorage = (key)=>{\n    if ( true && window.localStorage) {\n        return window.localStorage.getItem(key);\n    }\n    return null;\n};\nconst setLocalStorage = (key, value)=>{\n    if ( true && window.localStorage) {\n        window.localStorage.setItem(key, value);\n    }\n};\nconst removeLocalStorage = (key)=>{\n    if ( true && window.localStorage) {\n        window.localStorage.removeItem(key);\n    }\n};\n// Mock implementation that simulates database operations\nclass MockDataService {\n    loadData() {\n        const savedData = getLocalStorage(\"circle-data\");\n        if (savedData) {\n            try {\n                const parsed = JSON.parse(savedData);\n                // Validate data structure\n                if (this.isValidData(parsed)) {\n                    this.data = parsed;\n                } else {\n                    console.warn(\"MockDataService: Invalid data format, using sample data\");\n                    removeLocalStorage(\"circle-data\");\n                }\n            } catch (error) {\n                console.error(\"MockDataService: Failed to parse saved data, using sample data\");\n                removeLocalStorage(\"circle-data\");\n            }\n        }\n    }\n    isValidData(data) {\n        return data.subjects && Array.isArray(data.subjects) && data.relationships && Array.isArray(data.relationships) && data.contacts && Array.isArray(data.contacts) && data.organizations && Array.isArray(data.organizations) && data.occupations && Array.isArray(data.occupations) && data.sentiments && Array.isArray(data.sentiments) && data.notes && Array.isArray(data.notes);\n    }\n    saveData() {\n        setLocalStorage(\"circle-data\", JSON.stringify(this.data));\n    }\n    simulateDelay() {\n        // Simulate network delay (50-200ms)\n        const delay = Math.random() * 150 + 50;\n        return new Promise((resolve)=>setTimeout(resolve, delay));\n    }\n    async updateContact(id, updates) {\n        await this.simulateDelay();\n        const contactIndex = this.data.contacts.findIndex((c)=>c.id === id);\n        if (contactIndex === -1) {\n            throw new Error(\"Contact with id \".concat(id, \" not found\"));\n        }\n        // Update the contact\n        this.data.contacts[contactIndex] = {\n            ...this.data.contacts[contactIndex],\n            ...updates\n        };\n        this.saveData();\n        return this.data.contacts[contactIndex];\n    }\n    async addContact(contact) {\n        await this.simulateDelay();\n        const newContact = {\n            ...contact,\n            id: Date.now(),\n            isTrashed: false\n        };\n        this.data.contacts.push(newContact);\n        this.saveData();\n        return newContact;\n    }\n    async deleteContact(id) {\n        await this.simulateDelay();\n        this.loadData(); // Ensure data is loaded\n        const initialLength = this.data.contacts.length;\n        this.data.contacts = this.data.contacts.filter((c)=>c.id !== id);\n        if (this.data.contacts.length === initialLength) {\n            throw new Error(\"Contact with id \".concat(id, \" not found\"));\n        }\n        this.saveData();\n    }\n    async addSubject(subject) {\n        await this.simulateDelay();\n        const newSubject = {\n            ...subject,\n            id: Date.now()\n        };\n        this.data.subjects.push(newSubject);\n        this.saveData();\n        return newSubject;\n    }\n    async addOrganization(organization) {\n        await this.simulateDelay();\n        const newOrganization = {\n            ...organization,\n            id: Date.now()\n        };\n        this.data.organizations.push(newOrganization);\n        this.saveData();\n        return newOrganization;\n    }\n    async addOccupation(occupation) {\n        await this.simulateDelay();\n        const newOccupation = {\n            ...occupation,\n            id: Date.now()\n        };\n        this.data.occupations.push(newOccupation);\n        this.saveData();\n        return newOccupation;\n    }\n    async addRelationship(relationship) {\n        await this.simulateDelay();\n        const newRelationship = {\n            ...relationship,\n            id: Date.now()\n        };\n        this.data.relationships.push(newRelationship);\n        this.saveData();\n        return newRelationship;\n    }\n    async addSentiment(sentiment) {\n        await this.simulateDelay();\n        const newSentiment = {\n            ...sentiment,\n            id: Date.now()\n        };\n        this.data.sentiments.push(newSentiment);\n        this.saveData();\n        return newSentiment;\n    }\n    async addNote(note) {\n        await this.simulateDelay();\n        const newNote = {\n            ...note,\n            id: Date.now(),\n            createdAt: new Date().toISOString(),\n            isTrashed: false\n        };\n        this.data.notes.push(newNote);\n        this.saveData();\n        return newNote;\n    }\n    async updateNote(id, updates) {\n        await this.simulateDelay();\n        const noteIndex = this.data.notes.findIndex((n)=>n.id === id);\n        if (noteIndex === -1) {\n            throw new Error(\"Note with id \".concat(id, \" not found\"));\n        }\n        // Update the note\n        this.data.notes[noteIndex] = {\n            ...this.data.notes[noteIndex],\n            ...updates\n        };\n        this.saveData();\n        return this.data.notes[noteIndex];\n    }\n    async addCommitment(commitment) {\n        await this.simulateDelay();\n        const newCommitment = {\n            ...commitment,\n            id: Date.now()\n        };\n        this.data.commitments.push(newCommitment);\n        this.saveData();\n        return newCommitment;\n    }\n    async updateCommitment(id, updates) {\n        await this.simulateDelay();\n        const idx = this.data.commitments.findIndex((c)=>c.id === id);\n        if (idx === -1) throw new Error(\"Commitment with id \".concat(id, \" not found\"));\n        this.data.commitments[idx] = {\n            ...this.data.commitments[idx],\n            ...updates\n        };\n        this.saveData();\n        return this.data.commitments[idx];\n    }\n    async getAllData() {\n        var _this_data_contacts_, _this_data_contacts_1;\n        console.log(\"\\uD83D\\uDCE1 MockDataService: getAllData called\");\n        console.log(\"\\uD83D\\uDD0D MockDataService: Current internal data source:\", {\n            isFromLocalStorage: this.data !== (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)(),\n            contactsCount: this.data.contacts.length,\n            sampleContactName: ((_this_data_contacts_ = this.data.contacts[0]) === null || _this_data_contacts_ === void 0 ? void 0 : _this_data_contacts_.name) || \"none\"\n        });\n        await this.simulateDelay();\n        // Reload from localStorage to get latest data\n        console.log(\"\\uD83D\\uDD04 MockDataService: Reloading from localStorage before returning data\");\n        this.loadData();\n        console.log(\"\\uD83D\\uDCE4 MockDataService: Returning data to caller:\", {\n            contactsCount: this.data.contacts.length,\n            notesCount: this.data.notes.length,\n            sampleContactName: ((_this_data_contacts_1 = this.data.contacts[0]) === null || _this_data_contacts_1 === void 0 ? void 0 : _this_data_contacts_1.name) || \"none\",\n            dataSource: this.data !== (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)() ? \"localStorage\" : \"sampleData\"\n        });\n        // Return a copy, post-processing notes so any embedded contact name references\n        // are synchronized to the current contact.name (instead of hardcoded samples)\n        const contactsCopy = [\n            ...this.data.contacts\n        ];\n        const originalSampleContacts = (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)().contacts;\n        const originalNameById = new Map(originalSampleContacts.map((c)=>[\n                c.id,\n                c.name\n            ]));\n        const normalizedNotes = this.data.notes.map((note)=>{\n            if (!note.contactIds || note.contactIds.length === 0) {\n                return {\n                    ...note\n                };\n            }\n            let updatedText = note.text;\n            for (const contactId of note.contactIds){\n                var _contactsCopy_find;\n                const current = (_contactsCopy_find = contactsCopy.find((c)=>c.id === contactId)) === null || _contactsCopy_find === void 0 ? void 0 : _contactsCopy_find.name;\n                const original = originalNameById.get(contactId);\n                if (!current || !original) continue;\n                // Replace full original name and its first-name-only variant with current full name\n                const originalFirst = original.split(\" \")[0];\n                const fullNamePattern = new RegExp(\"\\\\b\".concat(escapeRegExp(original), \"\\\\b\"), \"g\");\n                const firstNamePattern = new RegExp(\"\\\\b\".concat(escapeRegExp(originalFirst), \"\\\\b\"), \"g\");\n                updatedText = updatedText.replace(fullNamePattern, current);\n                updatedText = updatedText.replace(firstNamePattern, current);\n            }\n            return {\n                ...note,\n                text: updatedText\n            };\n        });\n        return {\n            contacts: contactsCopy,\n            subjects: [\n                ...this.data.subjects\n            ],\n            organizations: [\n                ...this.data.organizations\n            ],\n            occupations: [\n                ...this.data.occupations\n            ],\n            relationships: [\n                ...this.data.relationships\n            ],\n            sentiments: [\n                ...this.data.sentiments\n            ],\n            notes: normalizedNotes,\n            commitments: [\n                ...this.data.commitments\n            ]\n        };\n    }\n    constructor(){\n        // Initialize with sample data first, then try to load from localStorage\n        this.data = (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)();\n        // Load from localStorage only on the client side\n        if (true) {\n            this.loadData();\n        }\n    }\n}\n// Export singleton instance\nconst dataService = new MockDataService();\n// Utility for safe RegExp construction\nfunction escapeRegExp(input) {\n    return input.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlGLE9BQU8sTUFBa0MsT0FBNUJDLGFBQWFKLGdCQUFlLFFBQU07Z0JBQzVFUCxjQUFjQSxZQUFZYSxPQUFPLENBQUNKLGlCQUFpQk47Z0JBQ25ESCxjQUFjQSxZQUFZYSxPQUFPLENBQUNELGtCQUFrQlQ7WUFDdEQ7WUFDQSxPQUFPO2dCQUFFLEdBQUcvQixJQUFJO2dCQUFFNkIsTUFBTUQ7WUFBWTtRQUN0QztRQUVBLE9BQU87WUFDTDVFLFVBQVVxRTtZQUNWekUsVUFBVTttQkFBSSxJQUFJLENBQUNKLElBQUksQ0FBQ0ksUUFBUTthQUFDO1lBQ2pDSyxlQUFlO21CQUFJLElBQUksQ0FBQ1QsSUFBSSxDQUFDUyxhQUFhO2FBQUM7WUFDM0NDLGFBQWE7bUJBQUksSUFBSSxDQUFDVixJQUFJLENBQUNVLFdBQVc7YUFBQztZQUN2Q0gsZUFBZTttQkFBSSxJQUFJLENBQUNQLElBQUksQ0FBQ08sYUFBYTthQUFDO1lBQzNDSSxZQUFZO21CQUFJLElBQUksQ0FBQ1gsSUFBSSxDQUFDVyxVQUFVO2FBQUM7WUFDckNDLE9BQU9zRTtZQUNQaEIsYUFBYTttQkFBSSxJQUFJLENBQUNsRSxJQUFJLENBQUNrRSxXQUFXO2FBQUM7UUFDekM7SUFDRjtJQXJSQWdDLGFBQWM7UUFDWix3RUFBd0U7UUFDeEUsSUFBSSxDQUFDbEcsSUFBSSxHQUFHbEIsMERBQWFBO1FBQ3pCLGlEQUFpRDtRQUNqRCxJQUFJLElBQWtCLEVBQWE7WUFDakMsSUFBSSxDQUFDWSxRQUFRO1FBQ2Y7SUFDRjtBQStRRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNeUcsY0FBYyxJQUFJMUcsa0JBQWtCO0FBRWpELHVDQUF1QztBQUN2QyxTQUFTc0csYUFBYUssS0FBYTtJQUNqQyxPQUFPQSxNQUFNSCxPQUFPLENBQUMsdUJBQXVCO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2RhdGEvZGF0YVNlcnZpY2UudHM/ZjhmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250YWN0LCBTdWJqZWN0LCBPcmdhbml6YXRpb24sIE9jY3VwYXRpb24sIFJlbGF0aW9uc2hpcCwgU2VudGltZW50LCBOb3RlLCBDb21taXRtZW50IH0gZnJvbSAnLi4vY29udGV4dHMvQ29udGFjdENvbnRleHQnO1xuaW1wb3J0IHsgZ2V0U2FtcGxlRGF0YSB9IGZyb20gJy4vc2FtcGxlRGF0YSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVNlcnZpY2Uge1xuICB1cGRhdGVDb250YWN0KGlkOiBudW1iZXIsIHVwZGF0ZXM6IFBhcnRpYWw8Q29udGFjdD4pOiBQcm9taXNlPENvbnRhY3Q+O1xuICBhZGRDb250YWN0KGNvbnRhY3Q6IE9taXQ8Q29udGFjdCwgJ2lkJz4pOiBQcm9taXNlPENvbnRhY3Q+O1xuICBkZWxldGVDb250YWN0KGlkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuICBhZGRTdWJqZWN0KHN1YmplY3Q6IE9taXQ8U3ViamVjdCwgJ2lkJz4pOiBQcm9taXNlPFN1YmplY3Q+O1xuICBhZGRPcmdhbml6YXRpb24ob3JnYW5pemF0aW9uOiBPbWl0PE9yZ2FuaXphdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9yZ2FuaXphdGlvbj47XG4gIGFkZE9jY3VwYXRpb24ob2NjdXBhdGlvbjogT21pdDxPY2N1cGF0aW9uLCAnaWQnPik6IFByb21pc2U8T2NjdXBhdGlvbj47XG4gIGFkZFJlbGF0aW9uc2hpcChyZWxhdGlvbnNoaXA6IE9taXQ8UmVsYXRpb25zaGlwLCAnaWQnPik6IFByb21pc2U8UmVsYXRpb25zaGlwPjtcbiAgYWRkU2VudGltZW50KHNlbnRpbWVudDogT21pdDxTZW50aW1lbnQsICdpZCc+KTogUHJvbWlzZTxTZW50aW1lbnQ+O1xuICBhZGROb3RlKG5vdGU6IE9taXQ8Tm90ZSwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFByb21pc2U8Tm90ZT47XG4gIHVwZGF0ZU5vdGUoaWQ6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxOb3RlPik6IFByb21pc2U8Tm90ZT47XG4gIC8vIENvbW1pdG1lbnRzXG4gIGFkZENvbW1pdG1lbnQoY29tbWl0bWVudDogT21pdDxDb21taXRtZW50LCAnaWQnPik6IFByb21pc2U8Q29tbWl0bWVudD47XG4gIHVwZGF0ZUNvbW1pdG1lbnQoaWQ6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxDb21taXRtZW50Pik6IFByb21pc2U8Q29tbWl0bWVudD47XG4gIGdldEFsbERhdGEoKTogUHJvbWlzZTx7XG4gICAgY29udGFjdHM6IENvbnRhY3RbXTtcbiAgICBzdWJqZWN0czogU3ViamVjdFtdO1xuICAgIG9yZ2FuaXphdGlvbnM6IE9yZ2FuaXphdGlvbltdO1xuICAgIG9jY3VwYXRpb25zOiBPY2N1cGF0aW9uW107XG4gICAgcmVsYXRpb25zaGlwczogUmVsYXRpb25zaGlwW107XG4gICAgc2VudGltZW50czogU2VudGltZW50W107XG4gICAgbm90ZXM6IE5vdGVbXTtcbiAgICBjb21taXRtZW50czogQ29tbWl0bWVudFtdO1xuICB9Pjtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhZmVseSBhY2Nlc3MgbG9jYWxTdG9yYWdlXG5jb25zdCBnZXRMb2NhbFN0b3JhZ2UgPSAoa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBzZXRMb2NhbFN0b3JhZ2UgPSAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHJlbW92ZUxvY2FsU3RvcmFnZSA9IChrZXk6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9XG59O1xuXG4vLyBNb2NrIGltcGxlbWVudGF0aW9uIHRoYXQgc2ltdWxhdGVzIGRhdGFiYXNlIG9wZXJhdGlvbnNcbmV4cG9ydCBjbGFzcyBNb2NrRGF0YVNlcnZpY2UgaW1wbGVtZW50cyBEYXRhU2VydmljZSB7XG4gIHByaXZhdGUgZGF0YToge1xuICAgIGNvbnRhY3RzOiBDb250YWN0W107XG4gICAgc3ViamVjdHM6IFN1YmplY3RbXTtcbiAgICBvcmdhbml6YXRpb25zOiBPcmdhbml6YXRpb25bXTtcbiAgICBvY2N1cGF0aW9uczogT2NjdXBhdGlvbltdO1xuICAgIHJlbGF0aW9uc2hpcHM6IFJlbGF0aW9uc2hpcFtdO1xuICAgIHNlbnRpbWVudHM6IFNlbnRpbWVudFtdO1xuICAgIG5vdGVzOiBOb3RlW107XG4gICAgY29tbWl0bWVudHM6IENvbW1pdG1lbnRbXTtcbiAgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBJbml0aWFsaXplIHdpdGggc2FtcGxlIGRhdGEgZmlyc3QsIHRoZW4gdHJ5IHRvIGxvYWQgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICB0aGlzLmRhdGEgPSBnZXRTYW1wbGVEYXRhKCk7XG4gICAgLy8gTG9hZCBmcm9tIGxvY2FsU3RvcmFnZSBvbmx5IG9uIHRoZSBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2FkRGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbG9hZERhdGEoKSB7XG4gICAgY29uc3Qgc2F2ZWREYXRhID0gZ2V0TG9jYWxTdG9yYWdlKCdjaXJjbGUtZGF0YScpO1xuICAgIGlmIChzYXZlZERhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2F2ZWREYXRhKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERhdGEocGFyc2VkKSkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IHBhcnNlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ01vY2tEYXRhU2VydmljZTogSW52YWxpZCBkYXRhIGZvcm1hdCwgdXNpbmcgc2FtcGxlIGRhdGEnKTtcbiAgICAgICAgICByZW1vdmVMb2NhbFN0b3JhZ2UoJ2NpcmNsZS1kYXRhJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vY2tEYXRhU2VydmljZTogRmFpbGVkIHRvIHBhcnNlIHNhdmVkIGRhdGEsIHVzaW5nIHNhbXBsZSBkYXRhJyk7XG4gICAgICAgIHJlbW92ZUxvY2FsU3RvcmFnZSgnY2lyY2xlLWRhdGEnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzVmFsaWREYXRhKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXRhLnN1YmplY3RzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5zdWJqZWN0cykgJiYgXG4gICAgICAgICAgIGRhdGEucmVsYXRpb25zaGlwcyAmJiBBcnJheS5pc0FycmF5KGRhdGEucmVsYXRpb25zaGlwcykgJiZcbiAgICAgICAgICAgZGF0YS5jb250YWN0cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY29udGFjdHMpICYmXG4gICAgICAgICAgIGRhdGEub3JnYW5pemF0aW9ucyAmJiBBcnJheS5pc0FycmF5KGRhdGEub3JnYW5pemF0aW9ucykgJiZcbiAgICAgICAgICAgZGF0YS5vY2N1cGF0aW9ucyAmJiBBcnJheS5pc0FycmF5KGRhdGEub2NjdXBhdGlvbnMpICYmXG4gICAgICAgICAgIGRhdGEuc2VudGltZW50cyAmJiBBcnJheS5pc0FycmF5KGRhdGEuc2VudGltZW50cykgJiZcbiAgICAgICAgICAgZGF0YS5ub3RlcyAmJiBBcnJheS5pc0FycmF5KGRhdGEubm90ZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlRGF0YSgpOiB2b2lkIHtcbiAgICBzZXRMb2NhbFN0b3JhZ2UoJ2NpcmNsZS1kYXRhJywgSlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhKSk7XG4gIH1cblxuICBwcml2YXRlIHNpbXVsYXRlRGVsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gU2ltdWxhdGUgbmV0d29yayBkZWxheSAoNTAtMjAwbXMpXG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogMTUwICsgNTA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlQ29udGFjdChpZDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPENvbnRhY3Q+KTogUHJvbWlzZTxDb250YWN0PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgY29udGFjdEluZGV4ID0gdGhpcy5kYXRhLmNvbnRhY3RzLmZpbmRJbmRleChjID0+IGMuaWQgPT09IGlkKTtcbiAgICBpZiAoY29udGFjdEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250YWN0IHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgY29udGFjdFxuICAgIHRoaXMuZGF0YS5jb250YWN0c1tjb250YWN0SW5kZXhdID0geyBcbiAgICAgIC4uLnRoaXMuZGF0YS5jb250YWN0c1tjb250YWN0SW5kZXhdLCBcbiAgICAgIC4uLnVwZGF0ZXMgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb250YWN0c1tjb250YWN0SW5kZXhdO1xuICB9XG5cbiAgYXN5bmMgYWRkQ29udGFjdChjb250YWN0OiBPbWl0PENvbnRhY3QsICdpZCc+KTogUHJvbWlzZTxDb250YWN0PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgbmV3Q29udGFjdCA9IHsgXG4gICAgICAuLi5jb250YWN0LCBcbiAgICAgIGlkOiBEYXRlLm5vdygpLCAvLyBTaW1wbGUgSUQgZ2VuZXJhdGlvbiBmb3IgbW9ja1xuICAgICAgaXNUcmFzaGVkOiBmYWxzZVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5kYXRhLmNvbnRhY3RzLnB1c2gobmV3Q29udGFjdCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdDb250YWN0O1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQ29udGFjdChpZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgdGhpcy5sb2FkRGF0YSgpOyAvLyBFbnN1cmUgZGF0YSBpcyBsb2FkZWRcbiAgICBjb25zdCBpbml0aWFsTGVuZ3RoID0gdGhpcy5kYXRhLmNvbnRhY3RzLmxlbmd0aDtcbiAgICB0aGlzLmRhdGEuY29udGFjdHMgPSB0aGlzLmRhdGEuY29udGFjdHMuZmlsdGVyKChjOiBDb250YWN0KSA9PiBjLmlkICE9PSBpZCk7XG4gICAgXG4gICAgaWYgKHRoaXMuZGF0YS5jb250YWN0cy5sZW5ndGggPT09IGluaXRpYWxMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFjdCB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gIH1cblxuICBhc3luYyBhZGRTdWJqZWN0KHN1YmplY3Q6IE9taXQ8U3ViamVjdCwgJ2lkJz4pOiBQcm9taXNlPFN1YmplY3Q+IHtcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBcbiAgICBjb25zdCBuZXdTdWJqZWN0ID0geyBcbiAgICAgIC4uLnN1YmplY3QsIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEuc3ViamVjdHMucHVzaChuZXdTdWJqZWN0KTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld1N1YmplY3Q7XG4gIH1cblxuICBhc3luYyBhZGRPcmdhbml6YXRpb24ob3JnYW5pemF0aW9uOiBPbWl0PE9yZ2FuaXphdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9yZ2FuaXphdGlvbj4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld09yZ2FuaXphdGlvbiA9IHsgXG4gICAgICAuLi5vcmdhbml6YXRpb24sIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEub3JnYW5pemF0aW9ucy5wdXNoKG5ld09yZ2FuaXphdGlvbik7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdPcmdhbml6YXRpb247XG4gIH1cblxuICBhc3luYyBhZGRPY2N1cGF0aW9uKG9jY3VwYXRpb246IE9taXQ8T2NjdXBhdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9jY3VwYXRpb24+IHtcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBcbiAgICBjb25zdCBuZXdPY2N1cGF0aW9uID0geyBcbiAgICAgIC4uLm9jY3VwYXRpb24sIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEub2NjdXBhdGlvbnMucHVzaChuZXdPY2N1cGF0aW9uKTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld09jY3VwYXRpb247XG4gIH1cblxuICBhc3luYyBhZGRSZWxhdGlvbnNoaXAocmVsYXRpb25zaGlwOiBPbWl0PFJlbGF0aW9uc2hpcCwgJ2lkJz4pOiBQcm9taXNlPFJlbGF0aW9uc2hpcD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld1JlbGF0aW9uc2hpcCA9IHsgXG4gICAgICAuLi5yZWxhdGlvbnNoaXAsIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEucmVsYXRpb25zaGlwcy5wdXNoKG5ld1JlbGF0aW9uc2hpcCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdSZWxhdGlvbnNoaXA7XG4gIH1cblxuICBhc3luYyBhZGRTZW50aW1lbnQoc2VudGltZW50OiBPbWl0PFNlbnRpbWVudCwgJ2lkJz4pOiBQcm9taXNlPFNlbnRpbWVudD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld1NlbnRpbWVudCA9IHsgXG4gICAgICAuLi5zZW50aW1lbnQsIFxuICAgICAgaWQ6IERhdGUubm93KCkgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmRhdGEuc2VudGltZW50cy5wdXNoKG5ld1NlbnRpbWVudCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdTZW50aW1lbnQ7XG4gIH1cblxuICBhc3luYyBhZGROb3RlKG5vdGU6IE9taXQ8Tm90ZSwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFByb21pc2U8Tm90ZT4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld05vdGUgPSB7IFxuICAgICAgLi4ubm90ZSwgXG4gICAgICBpZDogRGF0ZS5ub3coKSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgaXNUcmFzaGVkOiBmYWxzZVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5kYXRhLm5vdGVzLnB1c2gobmV3Tm90ZSk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdOb3RlO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlTm90ZShpZDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPE5vdGU+KTogUHJvbWlzZTxOb3RlPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3Qgbm90ZUluZGV4ID0gdGhpcy5kYXRhLm5vdGVzLmZpbmRJbmRleChuID0+IG4uaWQgPT09IGlkKTtcbiAgICBpZiAobm90ZUluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3RlIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgbm90ZVxuICAgIHRoaXMuZGF0YS5ub3Rlc1tub3RlSW5kZXhdID0geyBcbiAgICAgIC4uLnRoaXMuZGF0YS5ub3Rlc1tub3RlSW5kZXhdLCBcbiAgICAgIC4uLnVwZGF0ZXMgXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5ub3Rlc1tub3RlSW5kZXhdO1xuICB9XG5cbiAgYXN5bmMgYWRkQ29tbWl0bWVudChjb21taXRtZW50OiBPbWl0PENvbW1pdG1lbnQsICdpZCc+KTogUHJvbWlzZTxDb21taXRtZW50PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgY29uc3QgbmV3Q29tbWl0bWVudDogQ29tbWl0bWVudCA9IHsgLi4uY29tbWl0bWVudCwgaWQ6IERhdGUubm93KCkgfTtcbiAgICB0aGlzLmRhdGEuY29tbWl0bWVudHMucHVzaChuZXdDb21taXRtZW50KTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld0NvbW1pdG1lbnQ7XG4gIH1cblxuICBhc3luYyB1cGRhdGVDb21taXRtZW50KGlkOiBudW1iZXIsIHVwZGF0ZXM6IFBhcnRpYWw8Q29tbWl0bWVudD4pOiBQcm9taXNlPENvbW1pdG1lbnQ+IHtcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBjb25zdCBpZHggPSB0aGlzLmRhdGEuY29tbWl0bWVudHMuZmluZEluZGV4KGMgPT4gYy5pZCA9PT0gaWQpO1xuICAgIGlmIChpZHggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYENvbW1pdG1lbnQgd2l0aCBpZCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB0aGlzLmRhdGEuY29tbWl0bWVudHNbaWR4XSA9IHsgLi4udGhpcy5kYXRhLmNvbW1pdG1lbnRzW2lkeF0sIC4uLnVwZGF0ZXMgfTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jb21taXRtZW50c1tpZHhdO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsRGF0YSgpOiBQcm9taXNlPHtcbiAgICBjb250YWN0czogQ29udGFjdFtdO1xuICAgIHN1YmplY3RzOiBTdWJqZWN0W107XG4gICAgb3JnYW5pemF0aW9uczogT3JnYW5pemF0aW9uW107XG4gICAgb2NjdXBhdGlvbnM6IE9jY3VwYXRpb25bXTtcbiAgICByZWxhdGlvbnNoaXBzOiBSZWxhdGlvbnNoaXBbXTtcbiAgICBzZW50aW1lbnRzOiBTZW50aW1lbnRbXTtcbiAgICBub3RlczogTm90ZVtdO1xuICAgIGNvbW1pdG1lbnRzOiBDb21taXRtZW50W107XG4gIH0+IHtcbiAgICBjb25zb2xlLmxvZygn8J+ToSBNb2NrRGF0YVNlcnZpY2U6IGdldEFsbERhdGEgY2FsbGVkJyk7XG4gICAgY29uc29sZS5sb2coJ/CflI0gTW9ja0RhdGFTZXJ2aWNlOiBDdXJyZW50IGludGVybmFsIGRhdGEgc291cmNlOicsIHtcbiAgICAgIGlzRnJvbUxvY2FsU3RvcmFnZTogdGhpcy5kYXRhICE9PSBnZXRTYW1wbGVEYXRhKCksXG4gICAgICBjb250YWN0c0NvdW50OiB0aGlzLmRhdGEuY29udGFjdHMubGVuZ3RoLFxuICAgICAgc2FtcGxlQ29udGFjdE5hbWU6IHRoaXMuZGF0YS5jb250YWN0c1swXT8ubmFtZSB8fCAnbm9uZSdcbiAgICB9KTtcbiAgICBcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlRGVsYXkoKTtcbiAgICBcbiAgICAvLyBSZWxvYWQgZnJvbSBsb2NhbFN0b3JhZ2UgdG8gZ2V0IGxhdGVzdCBkYXRhXG4gICAgY29uc29sZS5sb2coJ/CflIQgTW9ja0RhdGFTZXJ2aWNlOiBSZWxvYWRpbmcgZnJvbSBsb2NhbFN0b3JhZ2UgYmVmb3JlIHJldHVybmluZyBkYXRhJyk7XG4gICAgdGhpcy5sb2FkRGF0YSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn5OkIE1vY2tEYXRhU2VydmljZTogUmV0dXJuaW5nIGRhdGEgdG8gY2FsbGVyOicsIHtcbiAgICAgIGNvbnRhY3RzQ291bnQ6IHRoaXMuZGF0YS5jb250YWN0cy5sZW5ndGgsXG4gICAgICBub3Rlc0NvdW50OiB0aGlzLmRhdGEubm90ZXMubGVuZ3RoLFxuICAgICAgc2FtcGxlQ29udGFjdE5hbWU6IHRoaXMuZGF0YS5jb250YWN0c1swXT8ubmFtZSB8fCAnbm9uZScsXG4gICAgICBkYXRhU291cmNlOiB0aGlzLmRhdGEgIT09IGdldFNhbXBsZURhdGEoKSA/ICdsb2NhbFN0b3JhZ2UnIDogJ3NhbXBsZURhdGEnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgY29weSwgcG9zdC1wcm9jZXNzaW5nIG5vdGVzIHNvIGFueSBlbWJlZGRlZCBjb250YWN0IG5hbWUgcmVmZXJlbmNlc1xuICAgIC8vIGFyZSBzeW5jaHJvbml6ZWQgdG8gdGhlIGN1cnJlbnQgY29udGFjdC5uYW1lIChpbnN0ZWFkIG9mIGhhcmRjb2RlZCBzYW1wbGVzKVxuICAgIGNvbnN0IGNvbnRhY3RzQ29weSA9IFsuLi50aGlzLmRhdGEuY29udGFjdHNdO1xuICAgIGNvbnN0IG9yaWdpbmFsU2FtcGxlQ29udGFjdHMgPSBnZXRTYW1wbGVEYXRhKCkuY29udGFjdHM7XG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lQnlJZCA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KFxuICAgICAgb3JpZ2luYWxTYW1wbGVDb250YWN0cy5tYXAoKGMpID0+IFtjLmlkLCBjLm5hbWVdKVxuICAgICk7XG5cbiAgICBjb25zdCBub3JtYWxpemVkTm90ZXMgPSB0aGlzLmRhdGEubm90ZXMubWFwKChub3RlKSA9PiB7XG4gICAgICBpZiAoIW5vdGUuY29udGFjdElkcyB8fCBub3RlLmNvbnRhY3RJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm5vdGUgfTtcbiAgICAgIH1cbiAgICAgIGxldCB1cGRhdGVkVGV4dCA9IG5vdGUudGV4dDtcbiAgICAgIGZvciAoY29uc3QgY29udGFjdElkIG9mIG5vdGUuY29udGFjdElkcykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gY29udGFjdHNDb3B5LmZpbmQoKGMpID0+IGMuaWQgPT09IGNvbnRhY3RJZCk/Lm5hbWU7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gb3JpZ2luYWxOYW1lQnlJZC5nZXQoY29udGFjdElkKTtcbiAgICAgICAgaWYgKCFjdXJyZW50IHx8ICFvcmlnaW5hbCkgY29udGludWU7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBmdWxsIG9yaWdpbmFsIG5hbWUgYW5kIGl0cyBmaXJzdC1uYW1lLW9ubHkgdmFyaWFudCB3aXRoIGN1cnJlbnQgZnVsbCBuYW1lXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRmlyc3QgPSBvcmlnaW5hbC5zcGxpdCgnICcpWzBdO1xuICAgICAgICBjb25zdCBmdWxsTmFtZVBhdHRlcm4gPSBuZXcgUmVnRXhwKGBcXFxcYiR7ZXNjYXBlUmVnRXhwKG9yaWdpbmFsKX1cXFxcYmAsICdnJyk7XG4gICAgICAgIGNvbnN0IGZpcnN0TmFtZVBhdHRlcm4gPSBuZXcgUmVnRXhwKGBcXFxcYiR7ZXNjYXBlUmVnRXhwKG9yaWdpbmFsRmlyc3QpfVxcXFxiYCwgJ2cnKTtcbiAgICAgICAgdXBkYXRlZFRleHQgPSB1cGRhdGVkVGV4dC5yZXBsYWNlKGZ1bGxOYW1lUGF0dGVybiwgY3VycmVudCk7XG4gICAgICAgIHVwZGF0ZWRUZXh0ID0gdXBkYXRlZFRleHQucmVwbGFjZShmaXJzdE5hbWVQYXR0ZXJuLCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLm5vdGUsIHRleHQ6IHVwZGF0ZWRUZXh0IH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGFjdHM6IGNvbnRhY3RzQ29weSxcbiAgICAgIHN1YmplY3RzOiBbLi4udGhpcy5kYXRhLnN1YmplY3RzXSxcbiAgICAgIG9yZ2FuaXphdGlvbnM6IFsuLi50aGlzLmRhdGEub3JnYW5pemF0aW9uc10sXG4gICAgICBvY2N1cGF0aW9uczogWy4uLnRoaXMuZGF0YS5vY2N1cGF0aW9uc10sXG4gICAgICByZWxhdGlvbnNoaXBzOiBbLi4udGhpcy5kYXRhLnJlbGF0aW9uc2hpcHNdLFxuICAgICAgc2VudGltZW50czogWy4uLnRoaXMuZGF0YS5zZW50aW1lbnRzXSxcbiAgICAgIG5vdGVzOiBub3JtYWxpemVkTm90ZXMsXG4gICAgICBjb21taXRtZW50czogWy4uLnRoaXMuZGF0YS5jb21taXRtZW50c11cbiAgICB9O1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBkYXRhU2VydmljZSA9IG5ldyBNb2NrRGF0YVNlcnZpY2UoKTtcblxuLy8gVXRpbGl0eSBmb3Igc2FmZSBSZWdFeHAgY29uc3RydWN0aW9uXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuIl0sIm5hbWVzIjpbImdldFNhbXBsZURhdGEiLCJnZXRMb2NhbFN0b3JhZ2UiLCJrZXkiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0TG9jYWxTdG9yYWdlIiwidmFsdWUiLCJzZXRJdGVtIiwicmVtb3ZlTG9jYWxTdG9yYWdlIiwicmVtb3ZlSXRlbSIsIk1vY2tEYXRhU2VydmljZSIsImxvYWREYXRhIiwic2F2ZWREYXRhIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwiaXNWYWxpZERhdGEiLCJkYXRhIiwiY29uc29sZSIsIndhcm4iLCJlcnJvciIsInN1YmplY3RzIiwiQXJyYXkiLCJpc0FycmF5IiwicmVsYXRpb25zaGlwcyIsImNvbnRhY3RzIiwib3JnYW5pemF0aW9ucyIsIm9jY3VwYXRpb25zIiwic2VudGltZW50cyIsIm5vdGVzIiwic2F2ZURhdGEiLCJzdHJpbmdpZnkiLCJzaW11bGF0ZURlbGF5IiwiZGVsYXkiLCJNYXRoIiwicmFuZG9tIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidXBkYXRlQ29udGFjdCIsImlkIiwidXBkYXRlcyIsImNvbnRhY3RJbmRleCIsImZpbmRJbmRleCIsImMiLCJFcnJvciIsImFkZENvbnRhY3QiLCJjb250YWN0IiwibmV3Q29udGFjdCIsIkRhdGUiLCJub3ciLCJpc1RyYXNoZWQiLCJwdXNoIiwiZGVsZXRlQ29udGFjdCIsImluaXRpYWxMZW5ndGgiLCJsZW5ndGgiLCJmaWx0ZXIiLCJhZGRTdWJqZWN0Iiwic3ViamVjdCIsIm5ld1N1YmplY3QiLCJhZGRPcmdhbml6YXRpb24iLCJvcmdhbml6YXRpb24iLCJuZXdPcmdhbml6YXRpb24iLCJhZGRPY2N1cGF0aW9uIiwib2NjdXBhdGlvbiIsIm5ld09jY3VwYXRpb24iLCJhZGRSZWxhdGlvbnNoaXAiLCJyZWxhdGlvbnNoaXAiLCJuZXdSZWxhdGlvbnNoaXAiLCJhZGRTZW50aW1lbnQiLCJzZW50aW1lbnQiLCJuZXdTZW50aW1lbnQiLCJhZGROb3RlIiwibm90ZSIsIm5ld05vdGUiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZU5vdGUiLCJub3RlSW5kZXgiLCJuIiwiYWRkQ29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJuZXdDb21taXRtZW50IiwiY29tbWl0bWVudHMiLCJ1cGRhdGVDb21taXRtZW50IiwiaWR4IiwiZ2V0QWxsRGF0YSIsImxvZyIsImlzRnJvbUxvY2FsU3RvcmFnZSIsImNvbnRhY3RzQ291bnQiLCJzYW1wbGVDb250YWN0TmFtZSIsIm5hbWUiLCJub3Rlc0NvdW50IiwiZGF0YVNvdXJjZSIsImNvbnRhY3RzQ29weSIsIm9yaWdpbmFsU2FtcGxlQ29udGFjdHMiLCJvcmlnaW5hbE5hbWVCeUlkIiwiTWFwIiwibWFwIiwibm9ybWFsaXplZE5vdGVzIiwiY29udGFjdElkcyIsInVwZGF0ZWRUZXh0IiwidGV4dCIsImNvbnRhY3RJZCIsImN1cnJlbnQiLCJmaW5kIiwib3JpZ2luYWwiLCJnZXQiLCJvcmlnaW5hbEZpcnN0Iiwic3BsaXQiLCJmdWxsTmFtZVBhdHRlcm4iLCJSZWdFeHAiLCJlc2NhcGVSZWdFeHAiLCJmaXJzdE5hbWVQYXR0ZXJuIiwicmVwbGFjZSIsImNvbnN0cnVjdG9yIiwiZGF0YVNlcnZpY2UiLCJpbnB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/dataService.ts\n"));

/***/ })

});