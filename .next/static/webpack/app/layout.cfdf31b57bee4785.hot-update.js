"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./data/dataService.ts":
/*!*****************************!*\
  !*** ./data/dataService.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockDataService: function() { return /* binding */ MockDataService; },\n/* harmony export */   dataService: function() { return /* binding */ dataService; }\n/* harmony export */ });\n/* harmony import */ var _sampleData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sampleData */ \"(app-pages-browser)/./data/sampleData.ts\");\n\n// Mock implementation that simulates database operations\nclass MockDataService {\n    loadData() {\n        const savedData = localStorage.getItem(\"circle-data\");\n        if (savedData) {\n            try {\n                const parsed = JSON.parse(savedData);\n                // Validate data structure\n                if (this.isValidData(parsed)) {\n                    return parsed;\n                } else {\n                    console.warn(\"MockDataService: Invalid data format, using sample data\");\n                    localStorage.removeItem(\"circle-data\");\n                }\n            } catch (error) {\n                console.error(\"MockDataService: Failed to parse saved data, using sample data\");\n                localStorage.removeItem(\"circle-data\");\n            }\n        }\n        return (0,_sampleData__WEBPACK_IMPORTED_MODULE_0__.getSampleData)();\n    }\n    isValidData(data) {\n        return data.subjects && Array.isArray(data.subjects) && data.relationships && Array.isArray(data.relationships) && data.contacts && Array.isArray(data.contacts) && data.organizations && Array.isArray(data.organizations) && data.occupations && Array.isArray(data.occupations) && data.sentiments && Array.isArray(data.sentiments) && data.notes && Array.isArray(data.notes);\n    }\n    saveData() {\n        localStorage.setItem(\"circle-data\", JSON.stringify(this.data));\n    }\n    simulateDelay() {\n        // Simulate network delay (50-200ms)\n        const delay = Math.random() * 150 + 50;\n        return new Promise((resolve)=>setTimeout(resolve, delay));\n    }\n    async updateContact(id, updates) {\n        await this.simulateDelay();\n        const contactIndex = this.data.contacts.findIndex((c)=>c.id === id);\n        if (contactIndex === -1) {\n            throw new Error(\"Contact with id \".concat(id, \" not found\"));\n        }\n        // Update the contact\n        this.data.contacts[contactIndex] = {\n            ...this.data.contacts[contactIndex],\n            ...updates\n        };\n        this.saveData();\n        return this.data.contacts[contactIndex];\n    }\n    async addContact(contact) {\n        await this.simulateDelay();\n        const newContact = {\n            ...contact,\n            id: Date.now() // Simple ID generation for mock\n        };\n        this.data.contacts.push(newContact);\n        this.saveData();\n        return newContact;\n    }\n    async deleteContact(id) {\n        await this.simulateDelay();\n        const initialLength = this.data.contacts.length;\n        this.data.contacts = this.data.contacts.filter((c)=>c.id !== id);\n        if (this.data.contacts.length === initialLength) {\n            throw new Error(\"Contact with id \".concat(id, \" not found\"));\n        }\n        this.saveData();\n    }\n    async addSubject(subject) {\n        await this.simulateDelay();\n        const newSubject = {\n            ...subject,\n            id: Date.now()\n        };\n        this.data.subjects.push(newSubject);\n        this.saveData();\n        return newSubject;\n    }\n    async addOrganization(organization) {\n        await this.simulateDelay();\n        const newOrganization = {\n            ...organization,\n            id: Date.now()\n        };\n        this.data.organizations.push(newOrganization);\n        this.saveData();\n        return newOrganization;\n    }\n    async addOccupation(occupation) {\n        await this.simulateDelay();\n        const newOccupation = {\n            ...occupation,\n            id: Date.now()\n        };\n        this.data.occupations.push(newOccupation);\n        this.saveData();\n        return newOccupation;\n    }\n    async addRelationship(relationship) {\n        await this.simulateDelay();\n        const newRelationship = {\n            ...relationship,\n            id: Date.now()\n        };\n        this.data.relationships.push(newRelationship);\n        this.saveData();\n        return newRelationship;\n    }\n    async addSentiment(sentiment) {\n        await this.simulateDelay();\n        const newSentiment = {\n            ...sentiment,\n            id: Date.now()\n        };\n        this.data.sentiments.push(newSentiment);\n        this.saveData();\n        return newSentiment;\n    }\n    async addNote(note) {\n        await this.simulateDelay();\n        const newNote = {\n            ...note,\n            id: Date.now(),\n            createdAt: new Date().toISOString()\n        };\n        this.data.notes.push(newNote);\n        this.saveData();\n        return newNote;\n    }\n    async getAllData() {\n        await this.simulateDelay();\n        // Reload from localStorage to get latest data\n        this.data = this.loadData();\n        // Return a copy to prevent direct mutations\n        return {\n            contacts: [\n                ...this.data.contacts\n            ],\n            subjects: [\n                ...this.data.subjects\n            ],\n            organizations: [\n                ...this.data.organizations\n            ],\n            occupations: [\n                ...this.data.occupations\n            ],\n            relationships: [\n                ...this.data.relationships\n            ],\n            sentiments: [\n                ...this.data.sentiments\n            ],\n            notes: [\n                ...this.data.notes\n            ]\n        };\n    }\n    constructor(){\n        this.data = this.loadData();\n    }\n}\n// Export singleton instance\nconst dataService = new MockDataService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksQ0FBQ0MsUUFBUTthQUFDO1lBQ2pDSyxlQUFlO21CQUFJLElBQUksQ0FBQ04sSUFBSSxDQUFDTSxhQUFhO2FBQUM7WUFDM0NDLGFBQWE7bUJBQUksSUFBSSxDQUFDUCxJQUFJLENBQUNPLFdBQVc7YUFBQztZQUN2Q0gsZUFBZTttQkFBSSxJQUFJLENBQUNKLElBQUksQ0FBQ0ksYUFBYTthQUFDO1lBQzNDSSxZQUFZO21CQUFJLElBQUksQ0FBQ1IsSUFBSSxDQUFDUSxVQUFVO2FBQUM7WUFDckNDLE9BQU87bUJBQUksSUFBSSxDQUFDVCxJQUFJLENBQUNTLEtBQUs7YUFBQztRQUM3QjtJQUNGO0lBL0xBaUQsYUFBYztRQUNaLElBQUksQ0FBQzFELElBQUksR0FBRyxJQUFJLENBQUNaLFFBQVE7SUFDM0I7QUE4TEY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTXVFLGNBQWMsSUFBSXhFLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9kYXRhL2RhdGFTZXJ2aWNlLnRzP2Y4ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGFjdCwgU3ViamVjdCwgT3JnYW5pemF0aW9uLCBPY2N1cGF0aW9uLCBSZWxhdGlvbnNoaXAsIFNlbnRpbWVudCwgTm90ZSB9IGZyb20gJy4uL2NvbnRleHRzL0NvbnRhY3RDb250ZXh0JztcbmltcG9ydCB7IGdldFNhbXBsZURhdGEgfSBmcm9tICcuL3NhbXBsZURhdGEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFTZXJ2aWNlIHtcbiAgdXBkYXRlQ29udGFjdChpZDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPENvbnRhY3Q+KTogUHJvbWlzZTxDb250YWN0PjtcbiAgYWRkQ29udGFjdChjb250YWN0OiBPbWl0PENvbnRhY3QsICdpZCc+KTogUHJvbWlzZTxDb250YWN0PjtcbiAgZGVsZXRlQ29udGFjdChpZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPjtcbiAgYWRkU3ViamVjdChzdWJqZWN0OiBPbWl0PFN1YmplY3QsICdpZCc+KTogUHJvbWlzZTxTdWJqZWN0PjtcbiAgYWRkT3JnYW5pemF0aW9uKG9yZ2FuaXphdGlvbjogT21pdDxPcmdhbml6YXRpb24sICdpZCc+KTogUHJvbWlzZTxPcmdhbml6YXRpb24+O1xuICBhZGRPY2N1cGF0aW9uKG9jY3VwYXRpb246IE9taXQ8T2NjdXBhdGlvbiwgJ2lkJz4pOiBQcm9taXNlPE9jY3VwYXRpb24+O1xuICBhZGRSZWxhdGlvbnNoaXAocmVsYXRpb25zaGlwOiBPbWl0PFJlbGF0aW9uc2hpcCwgJ2lkJz4pOiBQcm9taXNlPFJlbGF0aW9uc2hpcD47XG4gIGFkZFNlbnRpbWVudChzZW50aW1lbnQ6IE9taXQ8U2VudGltZW50LCAnaWQnPik6IFByb21pc2U8U2VudGltZW50PjtcbiAgYWRkTm90ZShub3RlOiBPbWl0PE5vdGUsICdpZCcgfCAnY3JlYXRlZEF0Jz4pOiBQcm9taXNlPE5vdGU+O1xuICBnZXRBbGxEYXRhKCk6IFByb21pc2U8e1xuICAgIGNvbnRhY3RzOiBDb250YWN0W107XG4gICAgc3ViamVjdHM6IFN1YmplY3RbXTtcbiAgICBvcmdhbml6YXRpb25zOiBPcmdhbml6YXRpb25bXTtcbiAgICBvY2N1cGF0aW9uczogT2NjdXBhdGlvbltdO1xuICAgIHJlbGF0aW9uc2hpcHM6IFJlbGF0aW9uc2hpcFtdO1xuICAgIHNlbnRpbWVudHM6IFNlbnRpbWVudFtdO1xuICAgIG5vdGVzOiBOb3RlW107XG4gIH0+O1xufVxuXG4vLyBNb2NrIGltcGxlbWVudGF0aW9uIHRoYXQgc2ltdWxhdGVzIGRhdGFiYXNlIG9wZXJhdGlvbnNcbmV4cG9ydCBjbGFzcyBNb2NrRGF0YVNlcnZpY2UgaW1wbGVtZW50cyBEYXRhU2VydmljZSB7XG4gIHByaXZhdGUgZGF0YToge1xuICAgIGNvbnRhY3RzOiBDb250YWN0W107XG4gICAgc3ViamVjdHM6IFN1YmplY3RbXTtcbiAgICBvcmdhbml6YXRpb25zOiBPcmdhbml6YXRpb25bXTtcbiAgICBvY2N1cGF0aW9uczogT2NjdXBhdGlvbltdO1xuICAgIHJlbGF0aW9uc2hpcHM6IFJlbGF0aW9uc2hpcFtdO1xuICAgIHNlbnRpbWVudHM6IFNlbnRpbWVudFtdO1xuICAgIG5vdGVzOiBOb3RlW107XG4gIH07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYXRhID0gdGhpcy5sb2FkRGF0YSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkRGF0YSgpIHtcbiAgICBjb25zdCBzYXZlZERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2lyY2xlLWRhdGEnKTtcbiAgICBpZiAoc2F2ZWREYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNhdmVkRGF0YSk7XG4gICAgICAgIC8vIFZhbGlkYXRlIGRhdGEgc3RydWN0dXJlXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWREYXRhKHBhcnNlZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTW9ja0RhdGFTZXJ2aWNlOiBJbnZhbGlkIGRhdGEgZm9ybWF0LCB1c2luZyBzYW1wbGUgZGF0YScpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdjaXJjbGUtZGF0YScpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNb2NrRGF0YVNlcnZpY2U6IEZhaWxlZCB0byBwYXJzZSBzYXZlZCBkYXRhLCB1c2luZyBzYW1wbGUgZGF0YScpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY2lyY2xlLWRhdGEnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdldFNhbXBsZURhdGEoKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNWYWxpZERhdGEoZGF0YTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGEuc3ViamVjdHMgJiYgQXJyYXkuaXNBcnJheShkYXRhLnN1YmplY3RzKSAmJiBcbiAgICAgICAgICAgZGF0YS5yZWxhdGlvbnNoaXBzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5yZWxhdGlvbnNoaXBzKSAmJlxuICAgICAgICAgICBkYXRhLmNvbnRhY3RzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5jb250YWN0cykgJiZcbiAgICAgICAgICAgZGF0YS5vcmdhbml6YXRpb25zICYmIEFycmF5LmlzQXJyYXkoZGF0YS5vcmdhbml6YXRpb25zKSAmJlxuICAgICAgICAgICBkYXRhLm9jY3VwYXRpb25zICYmIEFycmF5LmlzQXJyYXkoZGF0YS5vY2N1cGF0aW9ucykgJiZcbiAgICAgICAgICAgZGF0YS5zZW50aW1lbnRzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5zZW50aW1lbnRzKSAmJlxuICAgICAgICAgICBkYXRhLm5vdGVzICYmIEFycmF5LmlzQXJyYXkoZGF0YS5ub3Rlcyk7XG4gIH1cblxuICBwcml2YXRlIHNhdmVEYXRhKCk6IHZvaWQge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjaXJjbGUtZGF0YScsIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzaW11bGF0ZURlbGF5KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFNpbXVsYXRlIG5ldHdvcmsgZGVsYXkgKDUwLTIwMG1zKVxuICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5yYW5kb20oKSAqIDE1MCArIDUwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUNvbnRhY3QoaWQ6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxDb250YWN0Pik6IFByb21pc2U8Q29udGFjdD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IGNvbnRhY3RJbmRleCA9IHRoaXMuZGF0YS5jb250YWN0cy5maW5kSW5kZXgoYyA9PiBjLmlkID09PSBpZCk7XG4gICAgaWYgKGNvbnRhY3RJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFjdCB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdGhlIGNvbnRhY3RcbiAgICB0aGlzLmRhdGEuY29udGFjdHNbY29udGFjdEluZGV4XSA9IHsgXG4gICAgICAuLi50aGlzLmRhdGEuY29udGFjdHNbY29udGFjdEluZGV4XSwgXG4gICAgICAuLi51cGRhdGVzIFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiB0aGlzLmRhdGEuY29udGFjdHNbY29udGFjdEluZGV4XTtcbiAgfVxuXG4gIGFzeW5jIGFkZENvbnRhY3QoY29udGFjdDogT21pdDxDb250YWN0LCAnaWQnPik6IFByb21pc2U8Q29udGFjdD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld0NvbnRhY3QgPSB7IFxuICAgICAgLi4uY29udGFjdCwgXG4gICAgICBpZDogRGF0ZS5ub3coKSAvLyBTaW1wbGUgSUQgZ2VuZXJhdGlvbiBmb3IgbW9ja1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5kYXRhLmNvbnRhY3RzLnB1c2gobmV3Q29udGFjdCk7XG4gICAgdGhpcy5zYXZlRGF0YSgpO1xuICAgIHJldHVybiBuZXdDb250YWN0O1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlQ29udGFjdChpZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgaW5pdGlhbExlbmd0aCA9IHRoaXMuZGF0YS5jb250YWN0cy5sZW5ndGg7XG4gICAgdGhpcy5kYXRhLmNvbnRhY3RzID0gdGhpcy5kYXRhLmNvbnRhY3RzLmZpbHRlcihjID0+IGMuaWQgIT09IGlkKTtcbiAgICBcbiAgICBpZiAodGhpcy5kYXRhLmNvbnRhY3RzLmxlbmd0aCA9PT0gaW5pdGlhbExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250YWN0IHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2F2ZURhdGEoKTtcbiAgfVxuXG4gIGFzeW5jIGFkZFN1YmplY3Qoc3ViamVjdDogT21pdDxTdWJqZWN0LCAnaWQnPik6IFByb21pc2U8U3ViamVjdD4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld1N1YmplY3QgPSB7IFxuICAgICAgLi4uc3ViamVjdCwgXG4gICAgICBpZDogRGF0ZS5ub3coKSBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGF0YS5zdWJqZWN0cy5wdXNoKG5ld1N1YmplY3QpO1xuICAgIHRoaXMuc2F2ZURhdGEoKTtcbiAgICByZXR1cm4gbmV3U3ViamVjdDtcbiAgfVxuXG4gIGFzeW5jIGFkZE9yZ2FuaXphdGlvbihvcmdhbml6YXRpb246IE9taXQ8T3JnYW5pemF0aW9uLCAnaWQnPik6IFByb21pc2U8T3JnYW5pemF0aW9uPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgbmV3T3JnYW5pemF0aW9uID0geyBcbiAgICAgIC4uLm9yZ2FuaXphdGlvbiwgXG4gICAgICBpZDogRGF0ZS5ub3coKSBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGF0YS5vcmdhbml6YXRpb25zLnB1c2gobmV3T3JnYW5pemF0aW9uKTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld09yZ2FuaXphdGlvbjtcbiAgfVxuXG4gIGFzeW5jIGFkZE9jY3VwYXRpb24ob2NjdXBhdGlvbjogT21pdDxPY2N1cGF0aW9uLCAnaWQnPik6IFByb21pc2U8T2NjdXBhdGlvbj4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIGNvbnN0IG5ld09jY3VwYXRpb24gPSB7IFxuICAgICAgLi4ub2NjdXBhdGlvbiwgXG4gICAgICBpZDogRGF0ZS5ub3coKSBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGF0YS5vY2N1cGF0aW9ucy5wdXNoKG5ld09jY3VwYXRpb24pO1xuICAgIHRoaXMuc2F2ZURhdGEoKTtcbiAgICByZXR1cm4gbmV3T2NjdXBhdGlvbjtcbiAgfVxuXG4gIGFzeW5jIGFkZFJlbGF0aW9uc2hpcChyZWxhdGlvbnNoaXA6IE9taXQ8UmVsYXRpb25zaGlwLCAnaWQnPik6IFByb21pc2U8UmVsYXRpb25zaGlwPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgbmV3UmVsYXRpb25zaGlwID0geyBcbiAgICAgIC4uLnJlbGF0aW9uc2hpcCwgXG4gICAgICBpZDogRGF0ZS5ub3coKSBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGF0YS5yZWxhdGlvbnNoaXBzLnB1c2gobmV3UmVsYXRpb25zaGlwKTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld1JlbGF0aW9uc2hpcDtcbiAgfVxuXG4gIGFzeW5jIGFkZFNlbnRpbWVudChzZW50aW1lbnQ6IE9taXQ8U2VudGltZW50LCAnaWQnPik6IFByb21pc2U8U2VudGltZW50PiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgbmV3U2VudGltZW50ID0geyBcbiAgICAgIC4uLnNlbnRpbWVudCwgXG4gICAgICBpZDogRGF0ZS5ub3coKSBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGF0YS5zZW50aW1lbnRzLnB1c2gobmV3U2VudGltZW50KTtcbiAgICB0aGlzLnNhdmVEYXRhKCk7XG4gICAgcmV0dXJuIG5ld1NlbnRpbWVudDtcbiAgfVxuXG4gIGFzeW5jIGFkZE5vdGUobm90ZTogT21pdDxOb3RlLCAnaWQnIHwgJ2NyZWF0ZWRBdCc+KTogUHJvbWlzZTxOb3RlPiB7XG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlbGF5KCk7XG4gICAgXG4gICAgY29uc3QgbmV3Tm90ZSA9IHsgXG4gICAgICAuLi5ub3RlLCBcbiAgICAgIGlkOiBEYXRlLm5vdygpLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGF0YS5ub3Rlcy5wdXNoKG5ld05vdGUpO1xuICAgIHRoaXMuc2F2ZURhdGEoKTtcbiAgICByZXR1cm4gbmV3Tm90ZTtcbiAgfVxuXG4gIGFzeW5jIGdldEFsbERhdGEoKTogUHJvbWlzZTx7XG4gICAgY29udGFjdHM6IENvbnRhY3RbXTtcbiAgICBzdWJqZWN0czogU3ViamVjdFtdO1xuICAgIG9yZ2FuaXphdGlvbnM6IE9yZ2FuaXphdGlvbltdO1xuICAgIG9jY3VwYXRpb25zOiBPY2N1cGF0aW9uW107XG4gICAgcmVsYXRpb25zaGlwczogUmVsYXRpb25zaGlwW107XG4gICAgc2VudGltZW50czogU2VudGltZW50W107XG4gICAgbm90ZXM6IE5vdGVbXTtcbiAgfT4ge1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVEZWxheSgpO1xuICAgIFxuICAgIC8vIFJlbG9hZCBmcm9tIGxvY2FsU3RvcmFnZSB0byBnZXQgbGF0ZXN0IGRhdGFcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmxvYWREYXRhKCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IGRpcmVjdCBtdXRhdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFjdHM6IFsuLi50aGlzLmRhdGEuY29udGFjdHNdLFxuICAgICAgc3ViamVjdHM6IFsuLi50aGlzLmRhdGEuc3ViamVjdHNdLFxuICAgICAgb3JnYW5pemF0aW9uczogWy4uLnRoaXMuZGF0YS5vcmdhbml6YXRpb25zXSxcbiAgICAgIG9jY3VwYXRpb25zOiBbLi4udGhpcy5kYXRhLm9jY3VwYXRpb25zXSxcbiAgICAgIHJlbGF0aW9uc2hpcHM6IFsuLi50aGlzLmRhdGEucmVsYXRpb25zaGlwc10sXG4gICAgICBzZW50aW1lbnRzOiBbLi4udGhpcy5kYXRhLnNlbnRpbWVudHNdLFxuICAgICAgbm90ZXM6IFsuLi50aGlzLmRhdGEubm90ZXNdXG4gICAgfTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgZGF0YVNlcnZpY2UgPSBuZXcgTW9ja0RhdGFTZXJ2aWNlKCk7XG4iXSwibmFtZXMiOlsiZ2V0U2FtcGxlRGF0YSIsIk1vY2tEYXRhU2VydmljZSIsImxvYWREYXRhIiwic2F2ZWREYXRhIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsImlzVmFsaWREYXRhIiwiY29uc29sZSIsIndhcm4iLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJkYXRhIiwic3ViamVjdHMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWxhdGlvbnNoaXBzIiwiY29udGFjdHMiLCJvcmdhbml6YXRpb25zIiwib2NjdXBhdGlvbnMiLCJzZW50aW1lbnRzIiwibm90ZXMiLCJzYXZlRGF0YSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJzaW11bGF0ZURlbGF5IiwiZGVsYXkiLCJNYXRoIiwicmFuZG9tIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidXBkYXRlQ29udGFjdCIsImlkIiwidXBkYXRlcyIsImNvbnRhY3RJbmRleCIsImZpbmRJbmRleCIsImMiLCJFcnJvciIsImFkZENvbnRhY3QiLCJjb250YWN0IiwibmV3Q29udGFjdCIsIkRhdGUiLCJub3ciLCJwdXNoIiwiZGVsZXRlQ29udGFjdCIsImluaXRpYWxMZW5ndGgiLCJsZW5ndGgiLCJmaWx0ZXIiLCJhZGRTdWJqZWN0Iiwic3ViamVjdCIsIm5ld1N1YmplY3QiLCJhZGRPcmdhbml6YXRpb24iLCJvcmdhbml6YXRpb24iLCJuZXdPcmdhbml6YXRpb24iLCJhZGRPY2N1cGF0aW9uIiwib2NjdXBhdGlvbiIsIm5ld09jY3VwYXRpb24iLCJhZGRSZWxhdGlvbnNoaXAiLCJyZWxhdGlvbnNoaXAiLCJuZXdSZWxhdGlvbnNoaXAiLCJhZGRTZW50aW1lbnQiLCJzZW50aW1lbnQiLCJuZXdTZW50aW1lbnQiLCJhZGROb3RlIiwibm90ZSIsIm5ld05vdGUiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsImdldEFsbERhdGEiLCJjb25zdHJ1Y3RvciIsImRhdGFTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/dataService.ts\n"));

/***/ })

});